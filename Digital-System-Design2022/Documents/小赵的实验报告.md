<div class="cover" style="page-break-after:always;font-family:华文细黑;width:100%;height:100%;border:none;margin: 0 auto;text-align:center;">
    <div style="width:80%;;margin: 0 auto;height:0;padding-bottom:25%;">
        <img src="https://s1.ax1x.com/2022/11/05/xORzKe.png" alt="校名" style="width:100%;"/></div>
    <br><br>
      <br><br>
    <!--
	<div style="width:40%;margin: 0 auto;height:0;padding-bottom:40%;">
        <img src="校标.png" alt="校徽" style="width:100%;"/></div>	
	-->
    <p style="text-align:center;font-size:32pt;margin: 0 auto">数字系统综合设计</p>
    <!--<br><br>-->
    <p style="text-align:center;font-size:32pt;margin: 0 auto">实验报告 </p>
    <br><br>
    <br><br>
    <br><br>
    <br><br>
    <table style="border:none;text-align:center;width:80%;font-family:仿宋;margin: 0 auto;">
    <tbody style="font-family:仿宋;font-size:18pt;">
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">姓&emsp;&emsp;名</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">赵婧萱</td></tr>
        <tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">学&emsp;&emsp;号</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">920104330118</td></tr>
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">专&emsp;&emsp;业</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">电子信息工程 </td></tr>
        <tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">学&emsp;&emsp;院</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">电子工程与光电技术学院</td></tr>
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">指导老师</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">王建新</td></tr>
<!--    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">授课教师</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 2px solid;text-align:center;">[教师姓名]</td></tr>
-->
    </tbody></table>
 		<br><br><br><br><p style="text-align:center;">2022 年 11 月 1 日</p>
    <br><br>
</div>




# 摘要



# 目录



# 实验内容

## 设计内容与要求

### 学号显示（八位LED数码管动态扫描）

1. 把“2022”显示在左边四位LED数码管上，且点亮第4个 LED数码管的小数点，把个人学号最后4位显示在右边四位LED数 码管上，如下图所示；

   ![image-20221101165822260](https://s1.ax1x.com/2022/11/05/xOeyTS.png)

   数码管的片选扫描时钟是将板载100MHz主频分频而来的10kHz时钟。

2. 先进行仿真：包括功能仿真和综合后仿真。

### 频率控制字设置的频率值显示

1. 频率控制字K（8位二进制）用左边拨码开关SW7-SW0输入；

2. 对应的频率值显示在8位LED数码管上，且**点亮第4个LED数码管的小数点**。
   $$
   f=\frac{K}{2^N} f_c
   $$
   其中 N = 8为相位累加器字长，fc = 10MHz为DDS时钟频率。

3. 显示切换由右边地址开关DIP1-DIP0控制
	| dip[1:0] |          数码管显示           |
	| -------- | :---------------------------: |
	| 00       |       2022.学号最后4位        |
	| 01       | 设置的频率值（小数点在KHZ上） |

### 基于DDS的正弦信号产生（0-2MHz，频率步长小于40kHz)

1. DDS原理框图

   ![image-20221101173332579](https://s1.ax1x.com/2022/11/05/xOefln.png)

2. 时钟产生：100MHZ主频分频而成的10MHZ时钟

3. 存储器IP核的生成

- 生成ROM波形文件dds_sin.coe

- 通过示波器测量信号波形与频率值； 

- 检查示波器测量得到的频率值是否与设置的频率值一致。

### 正弦信号频率测量的FPGA实现

1. 设计电路，测量外部输入正弦信号(加到A/D转换器)的频率 （范围：0-2MHz)；

2. 测量的频率值显示在8位LED数码管上，且点亮第4个LED数码管的小数点；

3. 检查FPGA测量得到的频率值是否与输入信号频率值一致， 检查0-2MHz范围内的频率测量误差，要求误差绝对值不超过1Hz。

   注：频率测量电路调试时先用开发板产生的正弦信号作为输入，测试/验收时 对信号源产生的正弦信号要求同样可以测量频率。

### 提高部分：利用串口（手机蓝牙）设置正弦信号频率

1. 在手机上输入代表频率的7位十进制数字（0000000-2000000）Hz

2. 对应的频率值显示在8位LED数码管上，且点亮第4个LED数码管的小数点。

3. 使用示波器测量产生的正弦信号频率值，检查是否与设置的频率值一致。 
   - 要求1：误差绝对值小于20kHz。
   - 要求2：误差绝对值小于2kHz。

### 发挥部分：和本实验内容相关即可

1. 设计了一个基于PWM原理的呼吸灯。
2. 设计了一个调制度固定的AM调幅输出功能。

### 验收注意事项

- 所有功能的Verilog HDL 程序需要合在一起运行(否则酌情扣分）；
- 程序运行后复位信号只能使用一次；
- 程序运行后复位信号只能使用一次；
- 成绩以第一次验收为准，验收时要准备好回答问题。

## 总体设计思路

![系统框图](https://s1.ax1x.com/2022/11/05/xOe8eK.png)

## 模块设计

### 时钟分频模块

#### 原理

﻿分频器是指使输出信号频率为输入信号频率整数分之一的电子电路。在许多电子设备中如电子钟、频率合成器等，需要各种不同频率的信号协同工作，常用的方法是以稳定度高的晶体振荡器为主振源，通过变换得到所需要的各种频率成分，分频器是一种主要变换手段。

在verilog程序设计中，我们往往要对一个频率进行任意分频。比如， FPGA系统时钟是100MHz，而我们要产生的频率是10KHz，那么，我们需要对系统时钟进行分频。很容易想到用计数的方式来分频：100000000/10000 = 10000。

由于在本系统中对于分频的任意性要求不高，故采用偶数分频法。如果偶数分频系数过大，就需要对分频系数 N 循环计数进行分频。在计数周期达到分频系数中间数值 N/2 时进行时钟翻转，可保证分频后时钟的占空比为 50%。因为是偶数分频，也可以对分频系数中间数值 N/2 进行循环计数。

#### 程序展示

```verilog
module freq_div10
 # (parameter DIV_0CLK = 10 )
 (
    input clk,
    input rst_n,
    output clk_div10
    );
    reg [15:0]	cnt ;
    always @(posedge clk or negedge rst_n) begin	//计数
      if (!rst_n) begin
         cnt    <= 'b0 ;
      end
      else if (cnt == (DIV_0CLK/2)-1) begin
         cnt    <= 'b0 ;
      end
      else begin
         cnt    <= cnt + 1'b1 ;
      end
    end
   reg clk_div10_r ;
    always @(posedge clk or negedge rst_n)			//分频
   begin
      if (!rst_n)
      begin
         clk_div10_r <= 1'b0 ;
      end
      else if (cnt == (DIV_0CLK/2)-1 ) begin
         clk_div10_r <= ~clk_div10_r ;
      end
   end
   assign clk_div10 = clk_div10_r ;
endmodule
```

### 数码管显示模块

#### 原理

#####  八段数码管的驱动原理

led 数码管（LED Segment Displays）是由多个发光二极管封装在一起的器件，可分为七段数码管和八段数码管，区别在于八段数码管比七段数码管多一个用于显示小数点的发光二极管单元DP（decimal point），其基本单元是发光二极管。

<img src="https://img-blog.csdnimg.cn/20200812154008702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbW51c196,size_16,color_FFFFFF,t_70#pic_center" alt="八段数码管" style="zoom:33%;" />

数码管按照连接方式可分为共阳极数码管和共阴极数码管。其中，将所有发光二极管的阳极连接到一起形成公共阳极(COM)的数码管为共阳极数码管。反之，将所有发光二极管的阴极连接到一起形成公共阴极(COM)的数码管为共阴极数码管。在应用时应将共阴极数码管的公共极COM 接到地线 GND上，当某一字段发光二极管的阳极为高电平时，该字段点亮，当某一字段的阳极为低电平时，该字段不亮。

本实验所用的板载数码管采用共阴极结构。如果要让LED灯亮，那么对应的LED灯的阴极要接高电平。也就是说如果要显示数字‘0’，输入的数据应该为：“111_1110”。编码译码格式如下表所示：

<table>
    <tr>
        <td rowspan="2">待显示内容</td> 
        <td colspan="8">段码（二进制）</td> 
   </tr>
   <tr>
       <td>h</td>    
       <td>a</td>
       <td>b</td>
       <td>c</td>
       <td>d</td>
       <td>e</td>
       <td>f</td>
       <td>g</td>
   </tr>
   <tr>
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>0</td> 
   </tr>
       <tr>
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>0</td>
        <td>0</td> 
   </tr>
       <tr>
        <td>2</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td>
        <td>0</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>3</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>0</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>4</td>
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>5</td>
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>6</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>7</td> 
        <td>1</td>
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>0</td>
        <td>0</td> 
   </tr>
           <tr>
        <td>8</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
           <tr>
        <td>9</td>
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
           <tr>
        <td>a</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
           <tr>
        <td>b</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
           <tr>
        <td>c</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>0</td> 
   </tr>
           <tr>
        <td>d</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>0</td>
        <td>1</td> 
   </tr>       
    <tr>
        <td>e</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
    <tr>
        <td>f</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>0</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
    </table>


##### 多个数码管的显示原理

对于多个数码管，有两种可选的工作方式：静态显示和动态显示。

静态显示就是将每个数码管的八段LED全部引出，每输入一次新的数据，数码管变化一次，多个数码管可同时工作。如果想要驱动5个数码管静态显示则需要5×8=40根I/O端口来完成驱动。如此一来，在实际应用中则必须增加译码驱动器进行驱动，从而增加了硬件电路的复杂性。由于静态驱动的这一缺点，LED数码管动态显示接口应用更广。

动态驱动是将所有数码管的 8个显示字段"a、b、c、d、e、f、g、h"的同名端连接在一起，此外每个数码管的公共极 COM 需增加由各自独立I/O线控制的位选通控制电路。当要输出某一字形码时，所有数码管都会接收到相同的字形码，但究竟是哪个数码管会显示出字形取决于对位选通COM端电路的控制。只需将显示数码管的选通控制打开，该位就会显示出字形，而没有选通的数码管并不会点亮。

综上所述，动态驱动是通过分时轮流控制各数码管的 COM 端，使各个数码管轮流受控显示。在这一过程中，每位数码管的点亮时间为1～2ms，由于人的视觉暂留现象及发光二极管的余辉效应，尽管各位数码管并非同时点亮，但只要扫描速度足够快，人们观察到的就是一组稳定的显示数据，而不会产生闪烁感。在显示效果上，动态显示和静态显示相同的，但动态显示不仅能够节省大量的I/O端口，而且功耗更低。


#### 端口设计与参数定义

除了时钟、复位，我们需要输入4个要显示数字的BCD码和一个四位的小数点控制数据，输出8位的段选信号和4位的位选信号。故端口设计如下：

```verilog
module seg_display(
    input clk,
    input rst_n,
    input [3:0] hex0, //第一个数码管显示的数字
    input [3:0] hex1,
    input [3:0] hex2,
    input [3:0] hex3,
    input [3:0] dp_in, //小数点控制
    output reg [3:0] an,   //片选
    output reg [7:0] sseg  //段选
    );
```

#### 程序展示

```verilog
module seg_display(
    input clk,
    input rst_n,
    input [3:0] hex0, //第一个数码管显示的数字
    input [3:0] hex1,
    input [3:0] hex2,
    input [3:0] hex3,
    input [3:0] dp_in, //小数点控制
    output reg [3:0] an,   //片选
    output reg [7:0] sseg  //段选
    );
    wire [1:0] s;     
    reg [3:0] digit;
    wire [3:0] aen;
    reg [19:0] clkdiv;
    reg dp;
    assign s = clkdiv[19:18];
    assign aen = 4'b1111; // all turned off initially

    always @(posedge clk)// or posedge clr)
        begin
        case(s)
            0:begin
               digit = hex0;
               dp = dp_in[0];
            end
            1:begin
               digit = hex1;
               dp = dp_in[1];
            end
            2:begin
               digit = hex2;
               dp = dp_in[2]; 
            end
            3:begin
               digit = hex3;
               dp = dp_in[3]; 
            end
            default:digit = hex0;
        endcase
        end
     always@(*)
     begin
      case(digit)
       4'h0: 	sseg[6:0] = 7'b1111110; //共阴极数码管
       4'h1: 	sseg[6:0] = 7'b0110000;
       4'h2: 	sseg[6:0] = 7'b1101101;
       4'h3: 	sseg[6:0] = 7'b1111001;
       4'h4: 	sseg[6:0] = 7'b0110011;
       4'h5: 	sseg[6:0] = 7'b1011011;
       4'h6: 	sseg[6:0] = 7'b1011111;
       4'h7: 	sseg[6:0] = 7'b1110000;
       4'h8: 	sseg[6:0] = 7'b1111111;
       4'h9: 	sseg[6:0] = 7'b1111011;
       4'ha: 	sseg[6:0] = 7'b1110111;
       4'hb: 	sseg[6:0] = 7'b0011111;
       4'hc: 	sseg[6:0] = 7'b1001110;
       4'hd: 	sseg[6:0] = 7'b0111101;
       4'he: 	sseg[6:0] = 7'b1001111;
       default: sseg[6:0] = 7'b1000111;
      endcase
      sseg[7] = dp;
     end

    always @(*)begin
    	an=4'b0000;
    	if(aen[s] == 1)
    		an[s] = 1;
    end
     //clkdiv
    always @(posedge clk or negedge rst_n) begin
    	if (!rst_n)
    		clkdiv <= 0;
    	else
    		clkdiv <= clkdiv+1;
    end
endmodule
```

### 二进制转BCD码模块

#### 原理

##### 为什么需要二进制转BCD模块

在数码管显示中，我们需要将一串用二进制表示的数字转换为十进制，然后将十进制的各个位数拆开，也就是通常所说的BCD码。举个例子，“123”这个数的二进制表示为1111011，拆为BCD码则会变成4'b0001、4'b0010、4'b0011。

 显然，对于任意一个三位数分离它的百位、十位和个位可以通过整除来实现，verilog 语法同时也支持相乘（*）、相除（/）和取模（%）的运算符，综合器发现这些运算符时会通过调用 FPGA 内部的嵌入式乘法器来实现这些运算。由于在数字电路中乘除法和浮点数的实现较为复杂，所以其他的综合器或许并不直接提供支持或者会出现仿真与实际不一致的结果，在verilog代码中使用乘除法或者取模会使得代码失去可移植性，这里并不建议使用。

##### 二进制转BCD的实现算法

FPGA中的数码管显示、串口收发等应用会涉及到二进制和BCD码之间的转换，常见的有3种方法：除法取模运算、查找表、加3左移。大位宽下，取模除法运算耗费大量lut资源，查找表也不方便，常用一种加3左移的方法。

移位加三算法的流程如下（这里假设要分离的只有3个数位）：

1. 将二进制数左移一位（未满4位在前面填0）；
2. 如果移动了8位，那么二进制数就在百位、十位和个位列，计算结束；
3. 在任何一个BCD列中，如果任何一个二进制数大于或者等于5，就把这个数加上3；
4. 回到步骤1。

下图展示了十六进制数 0x3F 其转化 BCD 码的流程：

![img](http://images2015.cnblogs.com/blog/771733/201512/771733-20151202183713502-1296787884.png)

#### 端口设计与参数定义

我设计的模块使用24位二进制输入，28位BCD码输出（7个数字）。因为最大频率控制字为255，理论最大开关控制DDS输出频率为$\frac{255\times 10MHZ}{2^8}=9960937HZ=24'b100101111111110111101001$。

```verilog
    module binary_bcd(
    	input clk,
    	input rst_n,
        input [23:0] bin_in,		//输入的二进制数
        output reg [3:0] ones,		//个位
        output reg [3:0] tens,		//十位
        output reg [3:0] huns,		//百位
        output reg [3:0] thous,		//千位
        output reg [3:0] tenk,		//10k位
        output reg [3:0] hunk,		//100k位
        output reg [3:0] onem		//兆位
    );
```

#### 程序展示

```verilog
module binary_bcd(		//这只是一个单纯的二进制转BCD模块
    input clk,
    input rst_n,
    input [23:0] bin_in,
    output reg [3:0] ones,
    output reg [3:0] tens,
    output reg [3:0] huns,
    output reg [3:0] thous,
    output reg [3:0] tenk,
    output reg [3:0] hunk,
    output reg [3:0] onem
    );
    integer i;
    always @(posedge clk, negedge rst_n) 
    begin
    if(!rst_n) begin
   	ones 		= 4'd0;
	tens 		= 4'd0;
	huns 	    = 4'd0;
    thous 		= 4'd0;
    tenk 		= 4'd0;
    hunk 		= 4'd0;
    onem 		= 4'd0;
    end
    else begin
	ones 		= 4'd0;
	tens 		= 4'd0;
	huns 	    = 4'd0;
    thous 		= 4'd0;
    tenk 		= 4'd0;
    hunk 		= 4'd0;
    onem 		= 4'd0;
	
	for(i = 23; i >= 0; i = i - 1) begin
		if (ones >= 4'd5) 	ones = ones + 4'd3;
		if (tens >= 4'd5) 	tens = tens + 4'd3;
		if (huns >= 4'd5)   huns = huns + 4'd3;
        if (thous>= 4'd5)   thous= thous+ 4'd3;
        if (tenk >= 4'd5)   tenk = tenk + 4'd3;
        if (hunk >= 4'd5)   hunk = hunk + 4'd3;
        if (onem >= 4'd5)   onem = onem + 4'd3;
        onem    = { onem[2:0]  ,hunk[3]   };
        hunk    = { hunk[2:0]  ,tenk[3]   };
        tenk    = { tenk[2:0]  ,thous[3]  };
        thous   = { thous[2:0] ,huns[3]   };
		huns    = { huns[2:0]  ,tens[3]   };
		tens    = { tens[2:0]  ,ones[3]   };
		ones    = { ones[2:0]  ,bin_in[i] };
	end
    end
 end
endmodule
```

### DDS波形发生器模块

#### 原理



#### 程序展示

```verilog
module DDS8(
    input clk,          //10MHZ
    input rst_n,
    input [5:0] FRQ_W,  //频率控制字M
    output [13:0] o_wave
    );
    reg		[7:0]	phase_sum=0;
    wire	[7:0]	addr;
    wire    [7:0]   o_wave8bit;
    //相位累加器
    always @(posedge clk or negedge rst_n)begin
        if(!rst_n)
            phase_sum <= 8'd0;
        else 
            phase_sum <= phase_sum + FRQ_W;
    end
    assign addr = phase_sum[7:0];
    assign o_wave = {o_wave8bit,6'b000000};
    blk_mem_gen_0 rom_8_256 (
    .clka(clk),         // input wire clka
    .addra(addr),       // input wire [7 : 0] addra
    .douta(o_wave8bit)  // output wire [7 : 0] douta
    );
endmodule
```

```matlab
//matlab代码
clc;
clear all;
close all;

width = 8;   %位宽
depth = 2 ^ 8 ; %深度（采样点个数）
x = linspace(0, 2 * pi, depth);
y = sin(x);
y = round(y * (2 ^ (width - 1) - 1) + 2 ^ (width - 1) - 1);%量化
plot(y);

fid = fopen('dds_sin.coe','w');
fprintf(fid,'memory_initialization_radix=10;\n');
fprintf(fid,'memory_initialization_vector =\n');
fprintf(fid, '%d,\n', y);
fclose(fid);
```

```matlab
memory_initialization_radix=10;
memory_initialization_vector =
127,130,133,136,139,143,146,149,152,155,158,161,164,167,170,173,176,179,181,184,187,190,193,195,198,200,203,205,208,210,213,215,217,219,221,223,225,227,229,231,233,235,236,238,239,241,242,243,245,246,247,248,249,250,250,251,252,252,253,253,253,254,254,254,254,254,254,254,253,253,252,252,251,251,250,249,248,247,246,245,244,243,241,240,239,237,235,234,232,230,228,226,224,222,220,218,216,214,211,209,207,204,202,199,196,194,191,188,186,183,180,177,174,171,168,166,163,159,156,153,150,147,144,141,138,135,132,129,125,122,119,116,113,110,107,104,101,98,95,91,88,86,83,80,77,74,71,68,66,63,60,58,55,52,50,47,45,43,40,38,36,34,32,30,28,26,24,22,20,19,17,15,14,13,11,10,9,8,7,6,5,4,3,3,2,2,1,1,0,0,0,0,0,0,0,1,1,1,2,2,3,4,4,5,6,7,8,9,11,12,13,15,16,18,19,21,23,25,27,29,31,33,35,37,39,41,44,46,49,51,54,56,59,61,64,67,70,73,75,78,81,84,87,90,93,96,99,102,105,108,111,115,118,121,124,127,
```

### 测频模块

#### 原理

##### 测频

频率测量在电子设计和测量领域中经常用到，因此对频率测量方法的研究在实际工程应用中具有重要意义。

通常的频率测量方法有三种：直接测量法，间接测量法，等精度测量法。

##### 直接测频法

直接测量法也叫频率测量法，即在固定在时间t内对被测信号的脉冲数进行计数，然后求出单位时间内的脉冲数，即为被测信号的频率。

下图中的信号分别为：

sys_clk：系统的基准时钟

gate：根据基准时钟生成的闸门信号，用于生成一个固定的时间（例如1s，方便计算）

clk_fx：被测信号

![img](https://img-blog.csdnimg.cn/20210929004907738.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a2k54us55qE5Y2V5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

gate是在基准时钟下生成的固定时间信号，它持续的时间为 
$$
T_g = sys\_clk \times 计数个数N(可设置)
$$
在gate持续为高的时间内，可使用被测信号clk_fx对其进行计数，计数个数为cnt（图中为5），则cnt个被测信号的周期即为gate时长。

此种方法的本质是：同样的时间内分别使用两种时钟计时，则有
$$
T_g = T_{clk\_fx}\\

T_{sys\_clk} \times 计数个数N = T_{clk\_fx} \times cnt
$$
公式变换后：  
$$
clk\_fx = \frac{cnt \times sys\_clk} { 计数个数N}
$$
（其中clk_fx为待测信号频率，sys_clk为基准时钟频率）

##### 误差分析

 从图可以看出，在gate为高电平期间，被测信号实际上差不多有六个周期被囊括在内，但是因为被测信号是相对与系统的异步信号，相位不同，第一个周期无法被采样，所以实际采样为5，这样造成的误差为一个被测信号周期。可以预见，这种测量方法带来的测量误差即为一个被测信号周期。

那么理论上测得的准确频率：
$$
clk\_fx_e = \frac{cnt\times sys\_clk} {计数个数N}
$$

理论上cnt无误差。

实际上测量的频率值：
$$
clk\_fx = \frac{(cnt±1)\times sys\_clk} {计数个数N}
$$

cnt会存在一个周期的测量误差。
$$
测量误差 = |\frac{(clk\_fx_e - clk\_fx)}{clk\_fx_e} |  \times 100\% = \frac{1} {cnt} \times 100\%
$$
所以测得的cnt越大，那么测出来的误差值就小，而cnt越大则代表被测信号的频率越高，所以可以推断**该种测量方法适合测量高频信号**；此外，选择的**闸门时间越长**则被测信号的个数越多，同样**测量就越精确**，但是增大闸门时间又会带来测量时间过长的问题，需要依据具体需求进行取舍。

##### 正弦信号测频

上面的直接测频法只能测1位方波信号的频率，我们的待测信号却是从AD转换而来的10位数字化正弦信号，所以需要关键的一步——将正弦信号转换为方波信号。

1. 最直接的“一刀切”

   我们可以直观地想到，将正弦波取一个平均值作为零点，高于零点线的认为是1，低于的认为是0，这样就可以产生方波了。但是经过实际测量，信号发生器产生的波形是有着毛刺的，即使经过滤波电路也是如此。做了一下matlab仿真，结果如下：

   ![](https://s1.ax1x.com/2022/11/05/xOgPU0.png)

2. 双门限的迟滞比较器

	   由于毛刺的干扰，我们发现“一刀切”法的转换精度随着原始正弦信号峰峰值的增大而变高，但老师验收时测频要求峰峰值为1v。于是我们想到了使用迟滞比较器的原理，设上、下双门限来比较。
        
    当输入信号高于上门限时，为方波信号赋值1；当输入信号低于下门限时，赋值0；信号值处于双门限中间时，方波值跟随上一次改变后的状态。
    
    这样，就可以有效避免毛刺的干扰，极大提高测量精度了。
    
    ![双门限法对比](https://s1.ax1x.com/2022/11/05/xO20m9.png)
    
    附matlab代码：
    
    ```matlab
    t=0:0.01:10;
    s1=zeros(1,1001);   %一刀切法输出方波
    s2=zeros(1,1001);   %双门限法输出方波
    y=sin(pi*t)+0.3*randn(size(t));%生成sine
    zero=(max(y)+min(y))/2;%求均值
    gate=0.6;           %门限宽度/2
    status=0;           %状态变量
    for i=1:1:1001      %比较并赋值
        if y(1,i)>zero
            s1(1,i)=1;
        end
        if y(1,i)>zero+gate
            s2(1,i)=1;
            status=1;
        elseif y(1,i)<zero-gate
            s2(1,i)=0;
            status=0;
        else
            s2(1,i)=status;
        end
    end
    subplot(3,1,1)      ;%画图
    plot(t,y,'-r',[0,10],[zero,zero],'+ --',[0,10],[zero+gate,zero+gate],'+ --',[0,10],[zero-gate,zero-gate],'+ --')
    title('有噪声的正弦波')
    subplot(3,1,2);
    plot(t,s1)
    ylim([-0.5,1.5])
    title('一刀切法转方波')
    subplot(3,1,3);
    plot(t,s2)
    ylim([-0.5,1.5])
    title('双门限法转方波')
    ```



#### 端口设计与参数定义

- 闸门和非闸门时间设定为0.5s，则每1秒更新一次测量数据
- 使用计数器生成闸门时间，闸门时间取反得到非闸门时间
- 在闸门时间对被测信号计数
- 在非闸门时间更新测量数据
- 使用parameter定义参数，方便调用修改

```verilog
module cymometer_direct(
     input clk,
     input rst_n,
     input clk_fx,			//输入待测方波信号
    output  reg [31:0] fre	 //输出待测信号频率 
    );
```

#### 程序展示

```verilog
module AD_fre(
    input clk,
    input rst_n,
    input   [9:0]   AD_in,
    output  [3:0]   AD0,
    output  [3:0]   AD1,
    output  [3:0]   AD2,
    output  [3:0]   AD3,
    output  [3:0]   AD4,
    output  [3:0]   AD5,
    output  [3:0]   AD6
    );
    wire clk_div10;
    //测频输入的方波信号
    reg clk_fx;
    //测频输出的频率
    wire [31:0] fre;
    //用来获知AD输入平均电压的东西
    reg [9:0] max,min;
    wire [9:0] zero;
    always@(posedge clk_div10)
    begin
       if(!rst_n)begin
        max=10'd100;
        min=10'd100;
       end
       else if(AD_in > max)
            max <= AD_in;
       else if(AD_in < min) 
            min <= AD_in;
         end
    assign zero = (max+min)/2;
	//双门限比较
    always@(posedge clk_div10)
        begin
          if(AD_in[9:5] > zero[9:5])
                clk_fx <= 1'b1;         
          else if(AD_in[9:5] < zero[9:5])
                clk_fx <= 1'b0;   
          else
                clk_fx <= clk_fx;
        end
    cymometer_direct cymometer_direct1(
        //直接测频模块例化
    .clk    ( clk    ),
    .rst_n  ( rst_n  ),
    .clk_fx ( clk_fx ),
    .fre    ( fre )
    );
    binary_bcd ADfre_BCD(
        //二进制转BCD
        .clk    ( clk    ),
        .rst_n  ( rst_n  ),
        .bin_in ( fre[23:0] ),
        .ones   ( AD0   ),
        .tens   ( AD1   ),
        .huns   ( AD2   ),
        .thous  ( AD3   ),
        .tenk   ( AD4   ),
        .hunk   ( AD5   ),
        .onem   ( AD6   )
    );
    freq_div10 div10(
        clk,
        rst_n,
        clk_div10
    );
endmodule
```

### 蓝牙串口模块

#### 原理

##### 串口

##### 蓝牙透传

#### 端口设计与参数定义



#### 程序展示

```verilog
module bt_uart (
  input            clk_pin,      // Clock input (from pin)
  input            rst_pin,        // Active HIGH reset (from pin)
  // RS232 signals
  input            rxd_pin,        // RS232 RXD pin
  output           txd_pin,        // RS232 RXD pin
  //BT 
    output bt_pw_on,
    output bt_master_slave,
    output bt_sw_hw,
    output bt_rst_n,
    output bt_sw,
    output [31:0] bt_data32
    );
// Parameter definitions
  parameter BAUD_RATE           = 9600;   
  parameter CLOCK_RATE_RX       = 100_000_000;
  parameter CLOCK_RATE_TX       = 100_000_000; 
  wire        rst_i,rst_1;          
  wire        rxd_i;         
  wire        txd_o;
  // From Clock Generator
  wire        clk_rx;         // Receive clock
  wire        clk_tx;         // Transmit clock
  wire        clk_samp;       // Sample clock
  wire        clock_locked;   // Locked signal from clk_core
  // From Reset Generator
  wire        rst_clk_rx;     // Reset, synchronized to clk_rx
  wire        rst_clk_tx;     // Reset, synchronized to clk_tx
  // From the RS232 receiver
  wire        rxd_clk_rx;     // RXD signal synchronized to clk_rx
  wire        rx_data_rdy;    // New character is ready
  wire [7:0]  rx_data;        // New character
  // From the response generator back to the command parser
  wire        send_resp_done;   // The response generation is complete
  // Instantiate input/output buffers
  IBUF IBUF_rst_i0      (.I (rst_1),      .O (rst_i));
  IBUF IBUF_rxd_i0      (.I (rxd_pin),      .O (rxd_i));
  OBUF OBUF_txd         (.I(txd_o),         .O(txd_pin));
  assign rst_1 = !rst_pin;
  // Instantiate the clock generator
  clk_gen clk_gen_i0 (
    .clk_pin         (clk_pin),         // Input clock pin
    .rst_i           (rst_i),           // Asynchronous input from IBUF
    .rst_clk_tx      (rst_clk_tx),      // For clock divider
    .pre_clk_tx      ( ),      // Current divider
    .clk_rx          (clk_rx),          // Receive clock
    .clk_tx          (clk_tx),          // Transmit clock
    .clk_samp        ( ),        // Sample clock
    .en_clk_samp     ( ),     // Enable for clk_samp
    .clock_locked    (clock_locked)     // Locked signal from clk_core
  );
  // Instantiate the reset generator
  rst_gen rst_gen_i0 (
    .clk_rx          (clk_rx),          // Receive clock
    .clk_tx          (clk_tx),          // Transmit clock
    .clk_samp        ( ),        // Sample clock
    .rst_i           (rst_i),           // Asynchronous input
    .clock_locked    (clock_locked),    // Locked signal from clk_core
    .rst_clk_rx      (rst_clk_rx),      // Reset, synchronized to clk_rx
    .rst_clk_tx      (rst_clk_tx),      // Reset, synchronized to clk_tx
    .rst_clk_samp    ( )     // Reset, synchronized to clk_samp
  );
  // Instantiate the UART receiver
  uart_rx #(
    .BAUD_RATE   (BAUD_RATE),
    .CLOCK_RATE  (CLOCK_RATE_RX)
  ) uart_rx_i0 (
    .clk_rx      (clk_rx),              // Receive clock
    .rst_clk_rx  (rst_clk_rx),          // Reset, synchronized to clk_rx 
    .rxd_i       (rxd_i),               // RS232 receive pin
    .rxd_clk_rx  (rxd_clk_rx),          // RXD pin after sync to clk_rx
    .rx_data_rdy (rx_data_rdy),         // New character is ready
    .rx_data     (rx_data),             // New character
    .frm_err     ()                     // Framing error (unused)
  );
  // Instantiate the command parser
  cmd_parse cmd_parse_i0 (
    .clk_rx            (clk_rx),         // Clock input
    .rst_clk_rx        (rst_clk_rx),    // Reset - synchronous to clk_rx
    .rx_data           (rx_data),        // Character to be parsed
    .rx_data_rdy       (rx_data_rdy),    // Ready signal for rx_data
    // From Character FIFO
    .char_fifo_full    (), // The char_fifo is full
    // To/From Response generator
    .send_char_val     (),  // A character is ready to be sent
    .send_char         (),      // Character to be sent
    .send_resp_val     (),  // A response is requested
    .send_resp_type    (), // Type of response - see localparams
    .send_resp_data    (), // Data to be output
    .send_resp_done    (1), // The response generation is complete
	.bt_data32                (bt_data32)
  );
assign bt_master_slave = 1;
assign bt_sw_hw        = 0;
assign bt_rst_n        = 1;
assign bt_sw           = 1;
assign bt_pw_on        = 1;
endmodule
```

### BCD码转二进制模块与DDS的改进

#### 原理



#### 端口设计与参数定义

#### 程序展示

```verilog
module bcd_bin#(
    parameter  SIZE_bcd =8'd28  ,
    parameter  SIZE_bin =8'd24   
)
(
    input                       clk,
    input                       rstn,
    input       [SIZE_bcd-1:0]  data_bcd,
    output  reg [SIZE_bin-1:0]  data_bin,
    output  reg                 valid 
);

reg [ 7:0] cnt;
reg [SIZE_bcd-1:0] data_bcd_temp;
reg [SIZE_bin-1:0] data_bin_temp;

localparam  CYCCLE = SIZE_bcd/4;    //十进制位数

always @(posedge clk ) begin
    if (!rstn) begin
        cnt <= 0;
    end
    else begin
        if(cnt > CYCCLE)
            cnt <= 0;
        else
            cnt <= cnt +1;
    end
end

always @(posedge clk ) begin 
    if(!rstn ) begin
        valid <= 1'd0;    
        data_bcd_temp <= 0;
        data_bin_temp <= 0;
    end 
    else begin
        if ( cnt == 0 ) begin
            valid     <= 1'd0;
            data_bcd_temp <= data_bcd;
            data_bin_temp <= 0;
        end
        else if( cnt <= CYCCLE ) begin
            data_bin_temp <=  MULTI10(data_bin_temp) + data_bcd_temp[(SIZE_bcd+3-cnt*4)-:4];     //注意位索引写法，表示8'd43-cnt*4开始低4位
        end
        else if ( cnt == CYCCLE +1 ) begin
            data_bin <= data_bin_temp;
            valid    <= 1'd1;
        end
    end

end

//加法和位拼接：乘10运算--*8+*2 
//注意：输出数据位数
function [SIZE_bin-1:0] MULTI10 (input [SIZE_bin-1:0] a);   
begin
    MULTI10 = {a[SIZE_bin-4 :0],3'b000 } + {a[SIZE_bin-2 :0],1'b0 };      
end
endfunction

endmodule
```

### 呼吸灯模块

#### 原理



#### 端口设计与参数定义



#### 程序展示

```verilog
module pwm(  //端口的定义，包括输入端口和输出端口
    input clk,
    input rst,
    input pwm_dip,
    output [14:0] led
    );

    reg [24:0] cnt_reg;     //计数寄存器
    reg [14:0] light;       //LED灯寄存器
    reg DIR=1'b1;           //判断标识符，决定灯光强度的下一步变化
    reg [24:0] value;       //用于占空比的设置
    reg [6:0] cs;           //占空比的变化趋势，1~100

    always @ (posedge clk)  //边缘敏感，时钟上升沿到来触发
    begin
    if(!rst || !pwm_dip)
    begin   //以下为变量的初始化
        cnt_reg <= 0;
        cs <= 7'd0;
        value <= 0;
    end
    else
        cnt_reg <= cnt_reg+1;                   //计数器加1
        if(cnt_reg == 500000)                   //经过一个单位时间
            begin           
            if(DIR) begin                       //DIR=1时灯光逐渐变亮
                value <= value + 19'd5000;      //占空比变大
                cnt_reg <= 20'd0;               //计数器归0
                cs <= cs + 1'b1;                //次数+1
            end
            else begin
                value <= value - 19'd5000;      //占空比变小
                cnt_reg <= 20'd0;               //计数器归0
                cs <= cs - 1'b1;                //次数-1
            end
            end
        end
    
    always@(cnt_reg) begin          //电平敏感，其中信号有变化即执行
    //占空比变化的实现
        if(cnt_reg < value) begin   //当前计数器的数小于valuie
            light <= 15'h7fff;      //全1，即亮
        end 
        else begin                  //当前计数器的数小于valuie
            light <= 15'h0000;      //全0，即暗
        end
    end
    
    always @ (value) begin
    if (cs == 100) begin            //当cs达到100后，即占空比达到了1，灯最亮
        DIR <= 1'b0; end            //DIR=0，意味着接下来要开始变暗了
    if (cs == 0) begin              //当cs达到.后，即占空比达到了0，灯最暗
        DIR <= 1'd1; end            //DIR=1，意味着接下来要开始变亮了
    end  
    assign  led = light;            //将寄存器中中保存的电平赋值给线路进行相应电平的输出    
endmodule
```

### AM调制模块

#### 原理



#### 端口设计与参数定义



#### 程序展示

```verilog
module AM_create(
	input		clk,
	input		rst_n,
	output	signed	[13:0]	AM_mod
);
wire    [15:0]AM_mod1;
wire 	[7:0]	cos_s;
wire	signed	[7:0]	cos_c;
assign AM_mod = AM_mod1[15:2];

//------------调用出波模块------------//
cos_make		cos_make_inst0(
	.clk			(clk),
	.rst_n		(rst_n),
	.cos_s		(cos_s),
	.cos_c		(cos_c)
);
//-----------------------------------//

//------------调用乘法器--------------//
MULT		MULT_inst1(		
  .CLK	(clk),
  .A		(cos_s),
  .B		(cos_c),
  .P		(AM_mod1)
);

endmodule
```



## 调试与结果

### 学号显示

#### testbench

```verilog
//seg_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module seg_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
initial begin
     clk = 0;
     rst_n = 0; #(`Clock*20+1);
     rst_n = 1;
     forever
         #(`Clock/2) clk = ~clk;
end
seg_display seg_left(
    .clk   ( clk   ),
    .rst_n ( rst_n ),
    .hex0  ( 4'h2 ),
    .hex1  ( 4'h0  ),
    .hex2  ( 4'h2  ),
    .hex3  ( 4'h2  ),
    .dp_in ( 4'b1000 ),
    .an    ( an1    ),
    .sseg  ({dp1,sseg1} )
);
seg_display seg_right(
    .clk   ( clk   ),
    .rst_n ( rst_n ),
    .hex0  ( 4'h0 ),
    .hex1  ( 4'h1  ),
    .hex2  ( 4'h1  ),
    .hex3  ( 4'h8  ),
    .dp_in ( 4'b0000 ),
    .an    ( an2    ),
    .sseg  ({dp2,sseg2} )
);
endmodule
```



#### 仿真结果

![image-20221102210013403](https://s1.ax1x.com/2022/11/05/xODXIU.png)

### 开关输入频率控制字的DDS

#### testbench

```verilog
//swDDS_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module swDDS_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
    wire [13:0] o_wave;
    reg [7:0] sw;
    wire [3:0] ones,tens,huns,thous,tenk,hunk,onem;
    wire clk_div10,clk_div104,clk_div106;

    initial begin
        clk = 0;
        sw = 8'b0000_0000;
        rst_n = 0; #(`Clock*20+1);
        rst_n = 1;
     forever
         #(`Clock/2) clk = ~clk;
    end
    always@(posedge clk_div106)begin
        sw <= sw+1;
    end
    freq_div10#(
        .DIV_0CLK ( 10000 )
    )freq_div104(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div104 )
    );
    freq_div10#(
        .DIV_0CLK ( 100 )
    )freq_div106(
        .clk   ( clk_div104   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div106 )
    );
    freq_div10#(
        .DIV_0CLK ( 10 )
    )freq_div10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10 )
    );

    DDS8 u_DDS8(
        .clk   (clk_div10),
        .rst_n (  rst_n ),
        .FRQ_W ( sw[5:0]),
        .o_wave( o_wave )
    );
    sw_BCD u_sw_BCD(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .sw    ( sw    ),
        .ones  ( ones  ),
        .tens  ( tens  ),
        .huns  ( huns  ),
        .thous ( thous ),
        .tenk  ( tenk  ),
        .hunk  ( hunk  ),
        .onem  ( onem  )
    );
    seg_display seg_left(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( 4'h0 ),
        .hex1  ( onem  ),
        .hex2  ( hunk  ),
        .hex3  ( tenk  ),
        .dp_in ( 4'b0000 ),
        .an    ( an1    ),
        .sseg  ( {dp1,sseg1} )
    );
    seg_display seg_right(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( thous ),
        .hex1  ( huns  ),
        .hex2  ( tens  ),
        .hex3  ( ones  ),
        .dp_in ( 4'b0001 ),
        .an    ( an2    ),
        .sseg  ( {dp2,sseg2} )
    );
endmodule
```



#### 仿真结果

##### 整体仿真

![image-20221102222613236](https://s1.ax1x.com/2022/11/05/xODOaT.png)

##### 频率控制字为1时的波形

![image-20221102223401397](https://s1.ax1x.com/2022/11/05/xODLZV.png)

##### 频率控制字为12时的波形

![image-20221102224204992](https://s1.ax1x.com/2022/11/05/xODHrq.png)

### 测频

#### testbench

```verilog
//fre_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module fre_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
    wire [13:0] o_wave;
    wire [3:0] AD0,AD1,AD2,AD3,AD4,AD5,AD6;
    wire clk_div10;

    initial begin
        clk = 0;
        forever
            #(`Clock/2) clk = ~clk;
    end
    initial begin
        rst_n = 0; #(`Clock*200+1);
        rst_n = 1;
    end

    freq_div10#(
        .DIV_0CLK ( 10 )
    )freq_div10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10 )
    );

    DDS8 u_DDS8(
        .clk   (clk_div10),
        .rst_n (  rst_n ),
        .FRQ_W (   1   ),
        .o_wave( o_wave )
    );
    AD_fre u_AD_fre(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AD_in ( o_wave[13:4] ),
        .AD0   ( AD0   ),
        .AD1   ( AD1   ),
        .AD2   ( AD2   ),
        .AD3   ( AD3   ),
        .AD4   ( AD4   ),
        .AD5   ( AD5   ),
        .AD6   ( AD6   )
    );
    seg_display seg_left(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( 4'h0 ),
        .hex1  ( AD6  ),
        .hex2  ( AD5  ),
        .hex3  ( AD4  ),
        .dp_in ( 4'b0000 ),
        .an    ( an1    ),
        .sseg  ( {dp1,sseg1} )
    );
    seg_display seg_right(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( AD3 ),
        .hex1  ( AD2  ),
        .hex2  ( AD1  ),
        .hex3  ( AD0  ),
        .dp_in ( 4'b0001 ),
        .an    ( an2    ),
        .sseg  ( {dp2,sseg2} )
    );
endmodule

```



#### 仿真结果

##### 频率控制字为1时

![image-20221103005543711](https://s1.ax1x.com/2022/11/05/xODbq0.png)

理论频率值为$\frac{1\times10M}{2^8}=39062HZ$，仿真测得频率为39062HZ，完全一致。

##### 频率控制字为46时

![image-20221103200031708](https://s1.ax1x.com/2022/11/05/xODviF.png)

理论频率值为$\frac{46\times10M}{2^8}=1796875HZ$，仿真测得频率为1796860HZ，相对误差为。

### 蓝牙输入频率控制字的DDS

### 呼吸灯

### AM调制

## 收获与体验



# 参考文献

分频：

https://zhuanlan.zhihu.com/p/450117801?utm_id=0

转bcd：

https://blog.csdn.net/qq_40011737/article/details/121127850

dds:

https://blog.csdn.net/qq_34769608/article/details/110058982

https://www.cnblogs.com/christsong/p/5536995.html

https://www.cnblogs.com/yskn/p/9321697.html

https://blog.csdn.net/yindq1220/article/details/125173035

测频：

https://blog.csdn.net/wuzhikaidetb/article/details/112326945

bcd转2：

https://blog.csdn.net/qq_40011737/article/details/121375603?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121375603-blog-121195609.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121375603-blog-121195609.pc_relevant_recovery_v2&utm_relevant_index=9

https://blog.csdn.net/qq_40011737/article/details/121195609

AM：

https://blog.csdn.net/HOOKNET/article/details/79129451

# Verilog HDL程序

此处只放出顶层模块代码，其余代码在[我的GitHub仓库](https://github.com/starbovo/Digital-System-Design2022)里面，欢迎老师和各位同学参考。

```verilog
`timescale 1ns / 1ps
/*
please use GB2312 to open this file
designed by ZhaoJingxuan
final version in 2022/10/27
*/
module top_module(
    //100M时钟和复位信号
    input clk,
    input rst_n,
    //两个拨码开关和八个普通开关
    input   [1:0]   sw_mode,
    input   [7:0]   sw,
    //一个开关控制DDS频率控制字来源
    input dds_dip,
    input AM_dip,
    output dds_led,
    //呼吸灯15位输出，一个开关控制
    input pwm_dip,
    output [14:0] led,
    //串口引脚RX、TX
    input           rxd_pin,
    output          txd_pin,
    //蓝牙控制
    output bt_pw_on,
    output bt_master_slave,
    output bt_sw_hw,
    output bt_rst_n,
    output bt_sw,
    //AD和DA时钟
    output reg AD_clk,
    output reg DA_clk,
    //10位AD输入
    input   [9:0]   AD_in,
    //DA输出
    output [13:0] DA_out,//提供给DA转换器的信号
    //数码管引脚
    output [3:0] an1,   //片选
    output [7:0] sseg1,  //段选
    output [3:0] an2,   //片选
    output [7:0] sseg2  //段选
    );
    //十分频出来的10M时钟
    wire clk_div10;
    //DDS相关信号
    reg     [13:0]  o_wave;
    wire    [13:0]  sw_wave,bt_wave;
    reg             dds_state = 1'b0;    //DDS输出模式标志（sw or bt）
    wire signed	[13:0]	AM_mod;
    //下面是一堆数码管中间信号
    wire    [3:0]   DA0,DA1,DA2,DA3,DA4,DA5,DA6;
    wire    [3:0]   AD0,AD1,AD2,AD3,AD4,AD5,AD6;
    reg     [3:0]   num0,num1,num2,num3,num4,num5,num6,num7,dp0,dp1;
    //蓝牙接收到的数据的BCD信号（8位数字）
    wire    [31:0]  bt_data32;
    //经过溢出检查（计算后不超过2M）后的开关信号
    reg     [7:0]   sw_fil;
    //串口数据转二进制
    wire    [23:0]  bt_bin;             //转换为二进制之后的串口数据
    wire            bt_valid;           //转换可用标志
    //串口数据溢出检查
    reg     [20:0]  btbin_fil;          //经过溢出检查之后的串口数据
    wire    [11:0]  bt_fil;             //串口数据转化成的频率控制字
    wire    [35:0]  mid_var;            //计算中间变量，因为verilog隐藏线型最大32位不够
    //十分频时钟
        freq_div10#(
        .DIV_0CLK ( 10 )
        )clkdiv10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10  )
        );
    //将10M时钟给AD和DA模块的时钟
    always@(*)begin
        AD_clk<=clk_div10;
        DA_clk<=clk_div10;
    end
    //通过两位拨码开关选择模式
    always @(*)         
        begin
            case(sw_mode)
                2'b00:begin    //00显示2022+学号后四位（0118）
                    num7=4'h2;
                    num6=4'h0;
                    num5=4'h2;
                    num4=4'h2;
                    num3=4'h0;
                    num2=4'h1;
                    num1=4'h1;
                    num0=4'h8;
                    dp0=4'b1000;
                    dp1=4'b0000;
                  end    
                2'b01: begin    //01显示开关控制下的输出频率
                    num7=4'h0;
                    num6=DA6;
                    num5=DA5;
                    num4=DA4;
                    num3=DA3;
                    num2=DA2;
                    num1=DA1;
                    num0=DA0;
                    dp0=4'b0000;
                    dp1=4'b0001;
                    end
                2'b10: begin    //10显示AD测量频率结果
                    num7=4'h0;
                    num6=AD6;
                    num5=AD5;
                    num4=AD4;
                    num3=AD3;
                    num2=AD2;
                    num1=AD1;
                    num0=AD0;
                    dp0=4'b0000;
                    dp1=4'b0001;
                    end
                2'b11: begin    //11显示蓝牙控制下的输出频率
                    num7=bt_data32[31:28];
                    num6=bt_data32[27:24];
                    num5=bt_data32[23:20];
                    num4=bt_data32[19:16];
                    num3=bt_data32[15:12];
                    num2=bt_data32[11:8];
                    num1=bt_data32[7:4];
                    num0=bt_data32[3:0];
                    dp0=4'b0000;
                    dp1=4'b0001;
                end
            endcase
        end
    //溢出判断
    always @(*) begin               //开关输入的溢出判断
    //fout为2M时，频率控制字为2M*(2^8)/10M=8'd51=8'b00110011
        if(sw>8'b00110011)begin     //超出110011则赋为它
            sw_fil <= 8'b00110011;
        end
        else begin                  //未超出则保持原值
            sw_fil <= sw;
        end
    end
    always @(*) begin               //蓝牙输入的溢出判断
        if(bt_valid)begin
            if(bt_bin>24'd2000000)begin
                btbin_fil<=24'd2000000;
            end
            else begin
                btbin_fil<=bt_bin;
            end
        end
    end
    //频率控制字为fout*10M/2^14
    //因为要求误差小于2KHZ，意味着频率步进缩小到4KHZ
    //此时最小深度为4KHZ/(1*10MHZ)=2^14
    //所以蓝牙DDS输出时要采用不同的coe文件
    assign mid_var = (btbin_fil<<14);
    assign bt_fil = mid_var/10000000;
    //开关切换频率控制字来源，如果是蓝牙模式灯亮
    always@(*) begin
        if(AM_dip)
            o_wave<=AM_mod;
        else begin
            if(dds_dip)begin
                dds_state <= 1;
                o_wave<=bt_wave;
            end
            else begin
                dds_state <= 0;
                o_wave<=sw_wave;
            end
        end
    end
    assign dds_led = dds_state;
    assign DA_out = o_wave;
    //例化两个DDS
    DDS8 swdds(             //8*2^8 DDS
        .clk   ( clk_div10  ),
        .rst_n ( rst_n      ),
        .FRQ_W ( sw_fil[5:0]),
        .o_wave( sw_wave    )
    );
    DDS14 btdds(            //14*2^14 DDS
        .clk   ( clk_div10 ),
        .rst_n ( rst_n     ),
        .FRQ_W ( bt_fil    ),
        .o_wave( bt_wave   )
    );
    //例化AD测频模块
    AD_fre u_AD_fre(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AD_in ( AD_in ),
        .AD0   ( AD0   ),
        .AD1   ( AD1   ),
        .AD2   ( AD2   ),
        .AD3   ( AD3   ),
        .AD4   ( AD4   ),
        .AD5   ( AD5   ),
        .AD6   ( AD6   )
    );
    //例化蓝牙接收模块
    bt_uart u_bt_uart(
        .clk_pin         ( clk             ),
        .rst_pin         ( rst_n           ),
        .rxd_pin         ( rxd_pin         ),
        .txd_pin         ( txd_pin         ),
        .bt_pw_on        ( bt_pw_on        ),
        .bt_master_slave ( bt_master_slave ),
        .bt_sw_hw        ( bt_sw_hw        ),
        .bt_rst_n        ( bt_rst_n        ),
        .bt_sw           ( bt_sw           ),
        .bt_data32       ( bt_data32       )
    );
    //例化28bitsBCD码转24bits二进制模块
    bcd_bin#(
        .SIZE_bcd ( 28 ),
        .SIZE_bin ( 24 )
    )u_bcd_bin(
        .clk      ( clk              ),
        .rstn     ( rst_n            ),
        .data_bcd ( bt_data32[27:0]  ),
        .data_bin ( bt_bin           ),
        .valid    ( bt_valid         )
    );
    //例化24bits二进制转28bitsBCD码模块
    sw_BCD swin(        //开关输入的信号转BCD码
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .sw    ( sw_fil),
        .ones  ( DA0  ),
        .tens  ( DA1  ),
        .huns  ( DA2  ),
        .thous ( DA3  ),
        .tenk  ( DA4  ),
        .hunk  ( DA5  ),
        .onem  ( DA6  )
    );
    //八个数码管例化
    seg_display seg_left(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( num7  ),
        .hex1  ( num6  ),
        .hex2  ( num5  ),
        .hex3  ( num4  ),
        .dp_in ( dp0   ),
        .an    ( an1   ),
        .sseg  ( sseg1 )
    );
    seg_display seg_right(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( num3  ),
        .hex1  ( num2  ),
        .hex2  ( num1  ),
        .hex3  ( num0  ),
        .dp_in ( dp1   ),
        .an    ( an2   ),
        .sseg  ( sseg2 )
    );
    //呼吸灯模块例化
    pwm u_pwm(
        .clk     ( clk     ),
        .rst     ( rst_n   ),
        .pwm_dip ( pwm_dip ),
        .led     ( led     )
    );
    AM_create u_AM_create(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AM_mod  ( AM_mod  )
    );
endmodule
```

