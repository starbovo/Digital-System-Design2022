<div class="cover" style="page-break-after:always;font-family:华文细黑;width:100%;height:100%;border:none;margin: 0 auto;text-align:center;">
    <div style="width:80%;;margin: 0 auto;height:0;padding-bottom:25%;">
        <img src="https://s1.ax1x.com/2022/11/05/xORzKe.png" alt="校名" style="width:100%;"/></div>
    <br><br>
      <br><br>
    <!--
	<div style="width:40%;margin: 0 auto;height:0;padding-bottom:40%;">
        <img src="校标.png" alt="校徽" style="width:100%;"/></div>	
	-->
    <p style="text-align:center;font-size:32pt;margin: 0 auto">数字系统综合设计</p>
    <!--<br><br>-->
    <p style="text-align:center;font-size:32pt;margin: 0 auto">实验报告 </p>
    <br><br>
    <br><br>
    <br><br>
    <br><br>
    <table style="border:none;text-align:center;width:80%;font-family:仿宋;margin: 0 auto;">
    <tbody style="font-family:仿宋;font-size:18pt;">
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">姓&emsp;&emsp;名</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">赵婧萱</td></tr>
        <tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">学&emsp;&emsp;号</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">920104330118</td></tr>
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">专&emsp;&emsp;业</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">电子信息工程 </td></tr>
        <tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">学&emsp;&emsp;院</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">电子工程与光电技术学院</td></tr>
    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">指导老师</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 1px solid;text-align:center;">王建新</td></tr>
<!--    	<tr style="font-weight:bold;"> 
    		<td style="width:25%;text-align:right;">授课教师</td><td style="width:5%">：</td> 
    		<td style="font-weight:normal;border-bottom: 2px solid;text-align:center;">[教师姓名]</td></tr>
-->
    </tbody></table>
 		<br><br><br><br><p style="text-align:center;">2022 年 11 月 6 日</p>
    <br><br>
</div>





# 摘要

本实验为基于Vivado软件和EGO1硬件板卡的数字系统综合设计实验，使用Verilog编程，共完成了七个功能项，包括数码管学号显示、开关输入频率控制字的DDS正弦波发生器、测频仪、蓝牙输入频率控制字的DDS正弦波发生器、呼吸灯和固定AM波调制。此报告中包含了功能原理和实现方式介绍、Verilog部分程序和Vivado仿真结果图，完整程序将上传到[我的github仓库里](https://github.com/starbovo/Digital-System-Design2022)。

关键词 FPGA Verilog

$$
Abstract
$$

This experiment is a comprehensive design experiment of digital system based on Vivado software and EGO1 hardware board, using Verilog programming, a total of seven functional items have been completed, including digital tube number display, DDS sine wave generator for switching input frequency control words, frequency measuring instrument, DDS sine wave generator for Bluetooth input frequency control words, breathing lamp and fixed AM wave modulation. This report contains an introduction to the functional principle and implementation, some Verilog programs and Vivado simulation result diagrams, and the complete program will be uploaded to [My github repository](https://github.com/starbovo/Digital-System-Design2022).

# 目录

[TOC]



# 实验内容

## 设计内容与要求

### 学号显示（八位LED数码管动态扫描）

1. 把“2022”显示在左边四位LED数码管上，且点亮第4个 LED数码管的小数点，把个人学号最后4位显示在右边四位LED数 码管上，如下图所示；

   ![image-20221101165822260](https://s1.ax1x.com/2022/11/05/xOeyTS.png)

   数码管的片选扫描时钟是将板载100MHz主频分频而来的10kHz时钟。

2. 先进行仿真：包括功能仿真和综合后仿真。

### 频率控制字设置的频率值显示

1. 频率控制字K（8位二进制）用左边拨码开关SW7-SW0输入；

2. 对应的频率值显示在8位LED数码管上，且**点亮第4个LED数码管的小数点**。
   $$
   f=\frac{K}{2^N} f_c
   $$
   其中 N = 8为相位累加器字长，fc = 10MHz为DDS时钟频率。

3. 显示切换由右边地址开关DIP1-DIP0控制
	| dip[1:0] |          数码管显示           |
	| -------- | :---------------------------: |
	| 00       |       2022.学号最后4位        |
	| 01       | 设置的频率值（小数点在KHZ上） |

### 基于DDS的正弦信号产生（0-2MHz，频率步长小于40kHz)

1. DDS原理框图

   ![image-20221101173332579](https://s1.ax1x.com/2022/11/05/xOefln.png)

2. 时钟产生：100MHZ主频分频而成的10MHZ时钟

3. 存储器IP核的生成

- 生成ROM波形文件dds_sin.coe

- 通过示波器测量信号波形与频率值； 

- 检查示波器测量得到的频率值是否与设置的频率值一致。

### 正弦信号频率测量的FPGA实现

1. 设计电路，测量外部输入正弦信号(加到A/D转换器)的频率 （范围：0-2MHz)；

2. 测量的频率值显示在8位LED数码管上，且点亮第4个LED数码管的小数点；

3. 检查FPGA测量得到的频率值是否与输入信号频率值一致， 检查0-2MHz范围内的频率测量误差，要求误差绝对值不超过1Hz。

   注：频率测量电路调试时先用开发板产生的正弦信号作为输入，测试/验收时 对信号源产生的正弦信号要求同样可以测量频率。

### 提高部分：利用串口（手机蓝牙）设置正弦信号频率

1. 在手机上输入代表频率的7位十进制数字（0000000-2000000）Hz

2. 对应的频率值显示在8位LED数码管上，且点亮第4个LED数码管的小数点。

3. 使用示波器测量产生的正弦信号频率值，检查是否与设置的频率值一致。 
   - 要求1：误差绝对值小于20kHz。
   - 要求2：误差绝对值小于2kHz。

### 发挥部分：和本实验内容相关即可

1. 设计了一个基于PWM原理的呼吸灯。
2. 设计了一个调制度固定的AM调幅输出功能。

### 验收注意事项

- 所有功能的Verilog HDL 程序需要合在一起运行(否则酌情扣分）；
- 程序运行后复位信号只能使用一次；
- 程序运行后复位信号只能使用一次；
- 成绩以第一次验收为准，验收时要准备好回答问题。

## 总体设计思路

![系统框图](https://s1.ax1x.com/2022/11/05/xOe8eK.png)

## 模块设计

### 时钟分频模块

#### 原理

﻿分频器是指使输出信号频率为输入信号频率整数分之一的电子电路。在许多电子设备中如电子钟、频率合成器等，需要各种不同频率的信号协同工作，常用的方法是以稳定度高的晶体振荡器为主振源，通过变换得到所需要的各种频率成分，分频器是一种主要变换手段。

在verilog程序设计中，我们往往要对一个频率进行任意分频。比如， FPGA系统时钟是100MHz，而我们要产生的频率是10KHz，那么，我们需要对系统时钟进行分频。很容易想到用计数的方式来分频：100000000/10000 = 10000。

由于在本系统中对于分频的任意性要求不高，故采用偶数分频法。如果偶数分频系数过大，就需要对分频系数 N 循环计数进行分频。在计数周期达到分频系数中间数值 N/2 时进行时钟翻转，可保证分频后时钟的占空比为 50%。因为是偶数分频，也可以对分频系数中间数值 N/2 进行循环计数。

#### 程序展示

```verilog
module freq_div10
 # (parameter DIV_0CLK = 10 )
 (
    input clk,
    input rst_n,
    output clk_div10
    );
    reg [15:0]	cnt ;
    always @(posedge clk or negedge rst_n) begin	//计数
      if (!rst_n) begin
         cnt    <= 'b0 ;
      end
      else if (cnt == (DIV_0CLK/2)-1) begin
         cnt    <= 'b0 ;
      end
      else begin
         cnt    <= cnt + 1'b1 ;
      end
    end
   reg clk_div10_r ;
    always @(posedge clk or negedge rst_n)			//分频
   begin
      if (!rst_n)
      begin
         clk_div10_r <= 1'b0 ;
      end
      else if (cnt == (DIV_0CLK/2)-1 ) begin
         clk_div10_r <= ~clk_div10_r ;
      end
   end
   assign clk_div10 = clk_div10_r ;
endmodule
```

### 数码管显示模块

#### 原理

#####  八段数码管的驱动原理

led 数码管是由多个发光二极管封装在一起的器件，可分为七段数码管和八段数码管，区别在于八段数码管比七段数码管多一个用于显示小数点的发光二极管单元DP（decimal point），其基本单元是发光二极管。

<img src="https://img-blog.csdnimg.cn/20200812154008702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbW51c196,size_16,color_FFFFFF,t_70#pic_center" alt="八段数码管" style="zoom: 25%;" />

数码管按照连接方式可分为共阳极数码管和共阴极数码管。其中，将所有发光二极管的阳极连接到一起形成公共阳极的数码管为共阳极数码管。反之，将所有阴极连接到一起形成公共阴极的数码管为共阴极数码管。在应用时应将共阴极数码管的公共极COM 接到地线 GND上，当某一字段发光二极管的阳极为高电平时，该字段点亮，当某一字段的阳极为低电平时，该字段不亮。

本实验所用的板载数码管采用共阴极结构。如果要让LED灯亮，那么对应的LED灯的阴极要接高电平。也就是说如果要显示数字‘0’，输入的数据应该为：“111_1110”。编码译码格式如下表所示：

<table>
    <tr>
        <td rowspan="2">待显示内容</td> 
        <td colspan="8">段码（二进制）</td> 
   </tr>
   <tr>
       <td>h</td>    
       <td>a</td>
       <td>b</td>
       <td>c</td>
       <td>d</td>
       <td>e</td>
       <td>f</td>
       <td>g</td>
   </tr>
   <tr>
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>0</td> 
   </tr>
       <tr>
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>0</td>
        <td>0</td> 
   </tr>
       <tr>
        <td>2</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td>
        <td>0</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>3</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>0</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>4</td>
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>5</td>
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>6</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
       <tr>
        <td>7</td> 
        <td>1</td>
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td>
        <td>0</td>
        <td>0</td> 
   </tr>
           <tr>
        <td>8</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td>
        <td>1</td>
        <td>1</td> 
   </tr>
           <tr>
        <td>9</td>
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td>
        <td>1</td>
        <td>1</td> 
   </tr>
    </table>

##### 多个数码管的显示原理

对于多个数码管，有两种可选的工作方式：静态显示和动态显示。

静态显示就是将每个数码管的八段LED全部引出，每输入一次新的数据，数码管变化一次，多个数码管可同时工作。如果想要驱动5个数码管静态显示则需要5×8=40根I/O端口来完成驱动。如此一来，在实际应用中则必须增加译码驱动器进行驱动，从而增加了硬件电路的复杂性。由于静态驱动的这一缺点，LED数码管动态显示接口应用更广。

动态驱动是将所有数码管的 8个显示字段"a、b、c、d、e、f、g、h"的同名端连接在一起，此外每个数码管的公共极 COM 需增加由各自独立I/O线控制的位选通控制电路。当要输出某一字形码时，所有数码管都会接收到相同的字形码，但究竟是哪个数码管会显示出字形取决于对位选通COM端电路的控制。只需将显示数码管的选通控制打开，该位就会显示出字形，而没有选通的数码管并不会点亮。

综上所述，动态驱动是通过分时轮流控制各数码管的 COM 端，使各个数码管轮流受控显示。在这一过程中，每位数码管的点亮时间为1～2ms，由于人的视觉暂留现象及发光二极管的余辉效应，尽管各位数码管并非同时点亮，但只要扫描速度足够快，人们观察到的就是一组稳定的显示数据，而不会产生闪烁感。在显示效果上，动态显示和静态显示相同的，但动态显示不仅能够节省大量的I/O端口，而且功耗更低。


#### 端口设计与参数定义

除了时钟、复位，我们需要输入4个要显示数字的BCD码和一个四位的小数点控制数据，输出8位的段选信号和4位的位选信号。故端口设计如下：

```verilog
module seg_display(
    input clk,
    input rst_n,
    input [3:0] hex0, //第一个数码管显示的数字
    input [3:0] hex1,
    input [3:0] hex2,
    input [3:0] hex3,
    input [3:0] dp_in, //小数点控制
    output reg [3:0] an,   //片选
    output reg [7:0] sseg  //段选
    );
```

#### 程序展示

```verilog
module seg_display(
    input clk,
    input rst_n,
    input [3:0] hex0, //第一个数码管显示的数字
    input [3:0] hex1,
    input [3:0] hex2,
    input [3:0] hex3,
    input [3:0] dp_in, //小数点控制
    output reg [3:0] an,   //片选
    output reg [7:0] sseg  //段选
    );
    wire [1:0] s;     
    reg [3:0] digit;
    wire [3:0] aen;
    reg [19:0] clkdiv;
    reg dp;
    assign s = clkdiv[19:18];
    assign aen = 4'b1111; // all turned off initially

    always @(posedge clk)// or posedge clr)
        begin
        case(s)
            0:begin
               digit = hex0;
               dp = dp_in[0];
            end
            1:begin
               digit = hex1;
               dp = dp_in[1];
            end
            2:begin
               digit = hex2;
               dp = dp_in[2]; 
            end
            3:begin
               digit = hex3;
               dp = dp_in[3]; 
            end
            default:digit = hex0;
        endcase
        end
     always@(*)
     begin
      case(digit)
       4'h0: 	sseg[6:0] = 7'b1111110; //共阴极数码管
       4'h1: 	sseg[6:0] = 7'b0110000;
       4'h2: 	sseg[6:0] = 7'b1101101;
       4'h3: 	sseg[6:0] = 7'b1111001;
       4'h4: 	sseg[6:0] = 7'b0110011;
       4'h5: 	sseg[6:0] = 7'b1011011;
       4'h6: 	sseg[6:0] = 7'b1011111;
       4'h7: 	sseg[6:0] = 7'b1110000;
       4'h8: 	sseg[6:0] = 7'b1111111;
       4'h9: 	sseg[6:0] = 7'b1111011;
       4'ha: 	sseg[6:0] = 7'b1110111;
       4'hb: 	sseg[6:0] = 7'b0011111;
       4'hc: 	sseg[6:0] = 7'b1001110;
       4'hd: 	sseg[6:0] = 7'b0111101;
       4'he: 	sseg[6:0] = 7'b1001111;
       default: sseg[6:0] = 7'b1000111;
      endcase
      sseg[7] = dp;
     end

    always @(*)begin
    	an=4'b0000;
    	if(aen[s] == 1)
    		an[s] = 1;
    end
     //clkdiv
    always @(posedge clk or negedge rst_n) begin
    	if (!rst_n)
    		clkdiv <= 0;
    	else
    		clkdiv <= clkdiv+1;
    end
endmodule
```

### 二进制转BCD码模块

#### 原理

##### 为什么需要二进制转BCD模块

在数码管显示中，我们需要将一串用二进制表示的数字转换为十进制，然后将十进制的各个位数拆开，也就是通常所说的BCD码。举个例子，“123”这个数的二进制表示为1111011，拆为BCD码则会变成4'b0001、4'b0010、4'b0011。

 显然，对于任意一个三位数分离它的百位、十位和个位可以通过整除来实现，verilog 语法同时也支持相乘（*）、相除（/）和取模（%）的运算符，综合器发现这些运算符时会通过调用 FPGA 内部的嵌入式乘法器来实现这些运算。由于在数字电路中乘除法和浮点数的实现较为复杂，所以其他的综合器或许并不直接提供支持或者会出现仿真与实际不一致的结果，在verilog代码中使用乘除法或者取模会使得代码失去可移植性，这里并不建议使用。

##### 二进制转BCD的实现算法

FPGA中的数码管显示、串口收发等应用会涉及到二进制和BCD码之间的转换，常见的有3种方法：除法取模运算、查找表、加3左移。大位宽下，取模除法运算耗费大量lut资源，查找表也不方便，常用一种加3左移的方法。

移位加三算法的流程如下（这里假设要分离的只有3个数位）：

1. 将二进制数左移一位（未满4位在前面填0）；
2. 如果移动了8位，那么二进制数就在百位、十位和个位列，计算结束；
3. 在任何一个BCD列中，如果任何一个二进制数大于或者等于5，就把这个数加上3；
4. 回到步骤1。

下图展示了十六进制数 0x3F 其转化 BCD 码的流程：

![img](http://images2015.cnblogs.com/blog/771733/201512/771733-20151202183713502-1296787884.png)

#### 端口设计与参数定义

我设计的模块使用24位二进制输入，28位BCD码输出（7个数字）。因为最大频率控制字为255，理论最大开关控制DDS输出频率为$\frac{255\times 10MHZ}{2^8}=9960937HZ=24'b100101111111110111101001$。

```verilog
    module binary_bcd(
    	input clk,
    	input rst_n,
        input [23:0] bin_in,		//输入的二进制数
        output reg [3:0] ones,		//个位
        output reg [3:0] tens,		//十位
        output reg [3:0] huns,		//百位
        output reg [3:0] thous,		//千位
        output reg [3:0] tenk,		//10k位
        output reg [3:0] hunk,		//100k位
        output reg [3:0] onem		//兆位
    );
```

#### 程序展示

```verilog
module binary_bcd(		//这只是一个单纯的二进制转BCD模块
    input clk,
    input rst_n,
    input [23:0] bin_in,
    output reg [3:0] ones,
    output reg [3:0] tens,
    output reg [3:0] huns,
    output reg [3:0] thous,
    output reg [3:0] tenk,
    output reg [3:0] hunk,
    output reg [3:0] onem
    );
    integer i;
    always @(posedge clk, negedge rst_n) 
    begin
    if(!rst_n) begin
   	ones 		= 4'd0;
	tens 		= 4'd0;
	huns 	    = 4'd0;
    thous 		= 4'd0;
    tenk 		= 4'd0;
    hunk 		= 4'd0;
    onem 		= 4'd0;
    end
    else begin
	ones 		= 4'd0;
	tens 		= 4'd0;
	huns 	    = 4'd0;
    thous 		= 4'd0;
    tenk 		= 4'd0;
    hunk 		= 4'd0;
    onem 		= 4'd0;
	
	for(i = 23; i >= 0; i = i - 1) begin
		if (ones >= 4'd5) 	ones = ones + 4'd3;
		if (tens >= 4'd5) 	tens = tens + 4'd3;
		if (huns >= 4'd5)   huns = huns + 4'd3;
        if (thous>= 4'd5)   thous= thous+ 4'd3;
        if (tenk >= 4'd5)   tenk = tenk + 4'd3;
        if (hunk >= 4'd5)   hunk = hunk + 4'd3;
        if (onem >= 4'd5)   onem = onem + 4'd3;
        onem    = { onem[2:0]  ,hunk[3]   };
        hunk    = { hunk[2:0]  ,tenk[3]   };
        tenk    = { tenk[2:0]  ,thous[3]  };
        thous   = { thous[2:0] ,huns[3]   };
		huns    = { huns[2:0]  ,tens[3]   };
		tens    = { tens[2:0]  ,ones[3]   };
		ones    = { ones[2:0]  ,bin_in[i] };
	end
    end
 end
endmodule
```

### DDS波形发生器模块

#### 原理

DDS全称为直接数字频率合成（Direct Digital Synthesis），其基本原理是在一个周期波形数据下，通过选取其中全部数据或抽样部分数据组成新的波形，由奈奎斯特采样定理可知，最低两个采样点就可以组成一个波形，但实际上最少需要4个点。其原理框图如下：

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNzQ1ODU1LzIwMTUwNS8yMDE4NDEwMjY1MDk5NDkucG5n?x-oss-process=image/format,png" style="zoom: 50%;" />

其主要由相位控制字、频率控制字、相位累加器、波形存储器几部分组成。

波形存储器：存储一个周期波形的离散信号表格。

fc采样时钟：从RAM中读出采样值的频率。

频率控制字：是相位累加的步长，用以控制生成的波形频率。

相位累加器：用来控制波形的相位累加，组成完整的波形显示。

相位控制字：用以控制波形起始位置。

整个过程的概述就是，你提供给DDS模块一个频率控制字，它内部的相位累加器会以这个频率控制字为步长递增，形成一些等间隔的相位地址。有了地址，它就会以采样时钟的频率去查找ROM里面存放的波形数据表，将每个地址下的数据读出来，波形就生成成功了！

#### 程序展示

```verilog
module DDS8(
    input clk,          //10MHZ
    input rst_n,
    input [5:0] FRQ_W,  //频率控制字M
    output [13:0] o_wave
    );
    reg		[7:0]	phase_sum=0;
    wire	[7:0]	addr;
    wire    [7:0]   o_wave8bit;
    //相位累加器
    always @(posedge clk or negedge rst_n)begin
        if(!rst_n)
            phase_sum <= 8'd0;
        else 
            phase_sum <= phase_sum + FRQ_W;
    end
    assign addr = phase_sum[7:0];
    assign o_wave = {o_wave8bit,6'b000000};
    blk_mem_gen_0 rom_8_256 (
    .clka(clk),         // input wire clka
    .addra(addr),       // input wire [7 : 0] addra
    .douta(o_wave8bit)  // output wire [7 : 0] douta
    );
endmodule
```

```matlab
//matlab代码
clc;
clear all;
close all;

width = 8;   %位宽
depth = 2 ^ 8 ; %深度（采样点个数）
x = linspace(0, 2 * pi, depth);
y = sin(x);
y = round(y * (2 ^ (width - 1) - 1) + 2 ^ (width - 1) - 1);%量化
plot(y);

fid = fopen('dds_sin.coe','w');
fprintf(fid,'memory_initialization_radix=10;\n');
fprintf(fid,'memory_initialization_vector =\n');
fprintf(fid, '%d,\n', y);
fclose(fid);
```

```matlab
memory_initialization_radix=10;
memory_initialization_vector =
127,130,133,136,139,143,146,149,152,155,158,161,164,167,170,173,176,179,181,184,187,190,193,195,198,200,203,205,208,210,213,215,217,219,221,223,225,227,229,231,233,235,236,238,239,241,242,243,245,246,247,248,249,250,250,251,252,252,253,253,253,254,254,254,254,254,254,254,253,253,252,252,251,251,250,249,248,247,246,245,244,243,241,240,239,237,235,234,232,230,228,226,224,222,220,218,216,214,211,209,207,204,202,199,196,194,191,188,186,183,180,177,174,171,168,166,163,159,156,153,150,147,144,141,138,135,132,129,125,122,119,116,113,110,107,104,101,98,95,91,88,86,83,80,77,74,71,68,66,63,60,58,55,52,50,47,45,43,40,38,36,34,32,30,28,26,24,22,20,19,17,15,14,13,11,10,9,8,7,6,5,4,3,3,2,2,1,1,0,0,0,0,0,0,0,1,1,1,2,2,3,4,4,5,6,7,8,9,11,12,13,15,16,18,19,21,23,25,27,29,31,33,35,37,39,41,44,46,49,51,54,56,59,61,64,67,70,73,75,78,81,84,87,90,93,96,99,102,105,108,111,115,118,121,124,127,
```

### 测频模块

#### 原理

##### 测频

频率测量在电子设计和测量领域中经常用到，因此对频率测量方法的研究在实际工程应用中具有重要意义。

通常的频率测量方法有三种：直接测量法，间接测量法，等精度测量法。

##### 直接测频法

直接测量法也叫频率测量法，即在固定在时间t内对被测信号的脉冲数进行计数，然后求出单位时间内的脉冲数，即为被测信号的频率。

下图中的信号分别为：

sys_clk：系统的基准时钟

gate：根据基准时钟生成的闸门信号，用于生成一个固定的时间（例如1s，方便计算）

clk_fx：被测信号

![img](https://img-blog.csdnimg.cn/20210929004907738.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a2k54us55qE5Y2V5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

gate是在基准时钟下生成的固定时间信号，它持续的时间为 
$$
T_g = sys\_clk \times 计数个数N(可设置)
$$
在gate持续为高的时间内，可使用被测信号clk_fx对其进行计数，计数个数为cnt（图中为5），则cnt个被测信号的周期即为gate时长。

此种方法的本质是：同样的时间内分别使用两种时钟计时，则有
$$
T_g = T_{clk\_fx}\\

T_{sys\_clk} \times 计数个数N = T_{clk\_fx} \times cnt
$$
公式变换后：  
$$
clk\_fx = \frac{cnt \times sys\_clk} { 计数个数N}
$$
（其中clk_fx为待测信号频率，sys_clk为基准时钟频率）

##### 误差分析

 从图可以看出，在gate为高电平期间，被测信号实际上差不多有六个周期被囊括在内，但是因为被测信号是相对与系统的异步信号，相位不同，第一个周期无法被采样，所以实际采样为5，这样造成的误差为一个被测信号周期。可以预见，这种测量方法带来的测量误差即为一个被测信号周期。

那么理论上测得的准确频率：
$$
clk\_fx_e = \frac{cnt\times sys\_clk} {计数个数N}
$$

理论上cnt无误差。

实际上测量的频率值：
$$
clk\_fx = \frac{(cnt±1)\times sys\_clk} {计数个数N}
$$

cnt会存在一个周期的测量误差。
$$
测量误差 = |\frac{(clk\_fx_e - clk\_fx)}{clk\_fx_e} |  \times 100\% = \frac{1} {cnt} \times 100\%
$$
所以测得的cnt越大，那么测出来的误差值就小，而cnt越大则代表被测信号的频率越高，所以可以推断**该种测量方法适合测量高频信号**；此外，选择的**闸门时间越长**则被测信号的个数越多，同样**测量就越精确**，但是增大闸门时间又会带来测量时间过长的问题，需要依据具体需求进行取舍。

##### 正弦信号测频

上面的直接测频法只能测1位方波信号的频率，我们的待测信号却是从AD转换而来的10位数字化正弦信号，所以需要关键的一步——将正弦信号转换为方波信号。

1. 最直接的“一刀切”

   我们可以直观地想到，将正弦波取一个平均值作为零点，高于零点线的认为是1，低于的认为是0，这样就可以产生方波了。但是经过实际测量，信号发生器产生的波形是有着毛刺的，即使经过滤波电路也是如此。做了一下matlab仿真，结果如下：

   <img src="https://s1.ax1x.com/2022/11/05/xOgPU0.png" style="zoom: 67%;" />

2. 双门限的迟滞比较器

    由于毛刺的干扰，我们发现“一刀切”法的转换精度随着原始正弦信号峰峰值的增大而变高，但老师验收时测频要求峰峰值为1v。
     
    于是我们想到了使用迟滞比较器的原理，设上、下双门限来比较。
    
    当输入信号高于上门限时，为方波信号赋值1；当输入信号低于下门限时，赋值0；信号值处于双门限中间时，方波值跟随上一次改变后的状态。
    
    这样，就可以有效避免毛刺的干扰，极大提高测量精度了。
    
    <img src="https://s1.ax1x.com/2022/11/05/xO20m9.png" alt="双门限法对比" style="zoom:67%;" />
    
    附matlab代码：
    
    ```matlab
    t=0:0.01:10;
    s1=zeros(1,1001);   %一刀切法输出方波
    s2=zeros(1,1001);   %双门限法输出方波
    y=sin(pi*t)+0.3*randn(size(t));%生成sine
    zero=(max(y)+min(y))/2;%求均值
    gate=0.6;           %门限宽度/2
    status=0;           %状态变量
    for i=1:1:1001      %比较并赋值
        if y(1,i)>zero
            s1(1,i)=1;
        end
        if y(1,i)>zero+gate
            s2(1,i)=1;
            status=1;
        elseif y(1,i)<zero-gate
            s2(1,i)=0;
            status=0;
        else
            s2(1,i)=status;
        end
    end
    subplot(3,1,1)      ;%画图
    plot(t,y,'-r',[0,10],[zero,zero],'+ --',[0,10],[zero+gate,zero+gate],'+ --',[0,10],[zero-gate,zero-gate],'+ --')
    title('有噪声的正弦波')
    subplot(3,1,2);
    plot(t,s1)
    ylim([-0.5,1.5])
    title('一刀切法转方波')
    subplot(3,1,3);
    plot(t,s2)
    ylim([-0.5,1.5])
    title('双门限法转方波')
    ```



#### 端口设计与参数定义

- 闸门和非闸门时间设定为0.5s，则每1秒更新一次测量数据
- 使用计数器生成闸门时间，闸门时间取反得到非闸门时间
- 在闸门时间对被测信号计数
- 在非闸门时间更新测量数据
- 使用parameter定义参数，方便调用修改

```verilog
module cymometer_direct(
     input clk,
     input rst_n,
     input clk_fx,			//输入待测方波信号
    output  reg [31:0] fre	 //输出待测信号频率 
    );
```

#### 程序展示

```verilog
module AD_fre(
    input clk,
    input rst_n,
    input   [9:0]   AD_in,
    output  [3:0]   AD0,
    output  [3:0]   AD1,
    output  [3:0]   AD2,
    output  [3:0]   AD3,
    output  [3:0]   AD4,
    output  [3:0]   AD5,
    output  [3:0]   AD6
    );
    wire clk_div10;
    //测频输入的方波信号
    reg clk_fx;
    //测频输出的频率
    wire [31:0] fre;
    //用来获知AD输入平均电压的东西
    reg [9:0] max,min;
    wire [9:0] zero;
    always@(posedge clk_div10)
    begin
       if(!rst_n)begin
        max=10'd100;
        min=10'd100;
       end
       else if(AD_in > max)
            max <= AD_in;
       else if(AD_in < min) 
            min <= AD_in;
         end
    assign zero = (max+min)/2;
	//双门限比较
    always@(posedge clk_div10)
        begin
          if(AD_in[9:5] > zero[9:5])
                clk_fx <= 1'b1;         
          else if(AD_in[9:5] < zero[9:5])
                clk_fx <= 1'b0;   
          else
                clk_fx <= clk_fx;
        end
    cymometer_direct cymometer_direct1(
        //直接测频模块例化
    .clk    ( clk    ),
    .rst_n  ( rst_n  ),
    .clk_fx ( clk_fx ),
    .fre    ( fre )
    );
    binary_bcd ADfre_BCD(
        //二进制转BCD
        .clk    ( clk    ),
        .rst_n  ( rst_n  ),
        .bin_in ( fre[23:0] ),
        .ones   ( AD0   ),
        .tens   ( AD1   ),
        .huns   ( AD2   ),
        .thous  ( AD3   ),
        .tenk   ( AD4   ),
        .hunk   ( AD5   ),
        .onem   ( AD6   )
    );
    freq_div10 div10(
        clk,
        rst_n,
        clk_div10
    );
endmodule
```

### 蓝牙串口模块

#### 原理

##### 串口——异步收发传输器（UART）

- 串口通信的信号线只需要两条线就可以完成，TX和RX TX发送端 RX为接收端。
- 起始位，数据线从高变低，低有效为0，数据传输开始。
- 数据位，起始位传输之后便是数据位开始，一般为8位，传输时低位（LSB）在前,高位（MSB）在后。
- 校验位，校验位可以认为是一个特殊的数据位，通常使用的是奇偶校验，使用串口协议时通常取消奇偶校验位。
- 停止位，停止位高有效为1，他表示这一个个字节传输结束。
- 位时间，起始位、数据位、校验位的位宽度是一致的，停止位有0.5位、1位、1.5位格式，一般为1位。
- 空闲位，持续的高电平。
- 帧：从起始位开始到停止位结束的时间间隔称之为一帧。

##### 波特率（Band Rate）：

串口协议中很重要的一点就是波特率，波特率的概念是每秒钟传送码元的个数，就是一秒钟传输了几个二进制的个数，他的单位是Bit/s和bps两种。常见的串口速度有115200bps 9600bps等等，串口（RS232）的最大传输速率是 115200bps，表示一秒钟传输了115200个二进制 。

##### 接收模块设计思路

该模块支持任意波特率（理论上）的接收，但需要在使用该模块时使用参数将其例化，数据位8位，起始位和停止位各1位，无奇偶校验。

串口的传输是以起始位开始的，而起始位是将数据线拉低 ，所以我们需要捕捉数据线的下降沿，将接收数据线打拍3次，捕捉其下降沿。当捕捉到接收数据线的下降沿，拉高接收标志信号，标志模块进入接收过程；当接收完10个bit后，拉低接收标志信号，标志接收过程结束。

假设波特率为9600，则传输一个bit的时间为1s/9600，一个数据的传输共10bit(数据位8位，起始位和停止位各1位)，则共需要1s/960；假设系统时钟为50MHz（参数化以便适应不同的系统频率），则其周期为20ns，那么传输一个bit所需要的系统周期数为（1s/960）/ 20ns ≈ 5208（个）。在接收过程中使用一个计数器计数，计数区间为（0~5208-1），这样的区间一共10个（一个字节需要传输10个bit）；此外还需一个计数器对接收的bit数计数（每当上一个计数器计数到5207则表示接收完了一个bit），计数区间（0~9）。

在接收过程，根据计数器的值（接收bit计数器），在每个bit计数器的中间接收数据，将其移位寄存（在电平中间数据最稳定）。

若接收bit计数器 = 0，则代表是起始位，不需要接收。

若接收bit计数器 = 1，则代表此时接收到数据的最低位LSB（数据的传输总是低位在前，高位在后），将其赋值给寄存数据的最低位；

若接收bit计数器 = 8，则代表此时接收到数据的最高位MSB，将其赋值给寄存数据的最高位；

若接收bit计数器 = 9，则代表是停止位，不需要接收。

#### 程序展示

```verilog
module bt_uart (
  input            clk_pin,      // Clock input (from pin)
  input            rst_pin,        // Active HIGH reset (from pin)
  // RS232 signals
  input            rxd_pin,        // RS232 RXD pin
  output           txd_pin,        // RS232 RXD pin
  //BT 
    output bt_pw_on,
    output bt_master_slave,
    output bt_sw_hw,
    output bt_rst_n,
    output bt_sw,
    output [31:0] bt_data32
    );
// Parameter definitions
  parameter BAUD_RATE           = 9600;   
  parameter CLOCK_RATE_RX       = 100_000_000;
  parameter CLOCK_RATE_TX       = 100_000_000; 
  wire        rst_i,rst_1;          
  wire        rxd_i;         
  wire        txd_o;
  // From Clock Generator
  wire        clk_rx;         // Receive clock
  wire        clk_tx;         // Transmit clock
  wire        clk_samp;       // Sample clock
  wire        clock_locked;   // Locked signal from clk_core
  // From Reset Generator
  wire        rst_clk_rx;     // Reset, synchronized to clk_rx
  wire        rst_clk_tx;     // Reset, synchronized to clk_tx
  // From the RS232 receiver
  wire        rxd_clk_rx;     // RXD signal synchronized to clk_rx
  wire        rx_data_rdy;    // New character is ready
  wire [7:0]  rx_data;        // New character
  // From the response generator back to the command parser
  wire        send_resp_done;   // The response generation is complete
  // Instantiate input/output buffers
  IBUF IBUF_rst_i0      (.I (rst_1),      .O (rst_i));
  IBUF IBUF_rxd_i0      (.I (rxd_pin),      .O (rxd_i));
  OBUF OBUF_txd         (.I(txd_o),         .O(txd_pin));
  assign rst_1 = !rst_pin;
  // Instantiate the clock generator
  clk_gen clk_gen_i0 (
    .clk_pin         (clk_pin),         // Input clock pin
    .rst_i           (rst_i),           // Asynchronous input from IBUF
    .rst_clk_tx      (rst_clk_tx),      // For clock divider
    .pre_clk_tx      ( ),      // Current divider
    .clk_rx          (clk_rx),          // Receive clock
    .clk_tx          (clk_tx),          // Transmit clock
    .clk_samp        ( ),        // Sample clock
    .en_clk_samp     ( ),     // Enable for clk_samp
    .clock_locked    (clock_locked)     // Locked signal from clk_core
  );
  // Instantiate the reset generator
  rst_gen rst_gen_i0 (
    .clk_rx          (clk_rx),          // Receive clock
    .clk_tx          (clk_tx),          // Transmit clock
    .clk_samp        ( ),        // Sample clock
    .rst_i           (rst_i),           // Asynchronous input
    .clock_locked    (clock_locked),    // Locked signal from clk_core
    .rst_clk_rx      (rst_clk_rx),      // Reset, synchronized to clk_rx
    .rst_clk_tx      (rst_clk_tx),      // Reset, synchronized to clk_tx
    .rst_clk_samp    ( )     // Reset, synchronized to clk_samp
  );
  // Instantiate the UART receiver
  uart_rx #(
    .BAUD_RATE   (BAUD_RATE),
    .CLOCK_RATE  (CLOCK_RATE_RX)
  ) uart_rx_i0 (
    .clk_rx      (clk_rx),              // Receive clock
    .rst_clk_rx  (rst_clk_rx),          // Reset, synchronized to clk_rx 
    .rxd_i       (rxd_i),               // RS232 receive pin
    .rxd_clk_rx  (rxd_clk_rx),          // RXD pin after sync to clk_rx
    .rx_data_rdy (rx_data_rdy),         // New character is ready
    .rx_data     (rx_data),             // New character
    .frm_err     ()                     // Framing error (unused)
  );
  // Instantiate the command parser
  cmd_parse cmd_parse_i0 (
    .clk_rx            (clk_rx),         // Clock input
    .rst_clk_rx        (rst_clk_rx),    // Reset - synchronous to clk_rx
    .rx_data           (rx_data),        // Character to be parsed
    .rx_data_rdy       (rx_data_rdy),    // Ready signal for rx_data
    // From Character FIFO
    .char_fifo_full    (), // The char_fifo is full
    // To/From Response generator
    .send_char_val     (),  // A character is ready to be sent
    .send_char         (),      // Character to be sent
    .send_resp_val     (),  // A response is requested
    .send_resp_type    (), // Type of response - see localparams
    .send_resp_data    (), // Data to be output
    .send_resp_done    (1), // The response generation is complete
	.bt_data32                (bt_data32)
  );
assign bt_master_slave = 1;
assign bt_sw_hw        = 0;
assign bt_rst_n        = 1;
assign bt_sw           = 1;
assign bt_pw_on        = 1;
endmodule
```

### BCD码转二进制模块与DDS的改进

#### 原理

##### 资源节约型的BCD码转二进制算法

和二进制转BCD类似，我们可以使用一种串行方式进行。

即对data_bcd = 40’h123456790 ：

i=1， data_bin = 1;

i=2， data_bin = data_bin *10 +2;

i=3， data_bin = data_bin *10 +3;

i=4， data_bin = data_bin *10 +4;

i=5， data_bin = data_bin *10 +5;

i=6， data_bin = data_bin *10 +6;

i=7， data_bin = data_bin *10 +7;

i=8， data_bin = data_bin *10 +8;

i=9， data_bin = data_bin *10 +9;

i=10， data_bin = data_bin *10 +0;

由于i是计数器，经过10次计数，

这样，实际生成的只有一个乘法和加法器，而且*10还可以改写成加法移位形式，从而达到节约lut资源目的。

##### DDS深度拓展

由于在蓝牙模块中，我们需要实现输入频率与最终输出频率之间的误差不超过2KHZ，仍然沿袭开关频率控制字DDS中的$8\times256$ROM是不现实的。因为要求误差小于2KHZ，意味着频率步进缩小到4KHZ，此时最小深度为$\frac{4KHZ}{(1\times10MHZ)}=2^{14}$。所以蓝牙DDS配置ROM时要采用不同的coe文件。

#### 程序展示

```verilog
module bcd_bin#(
    parameter  SIZE_bcd =8'd28  ,
    parameter  SIZE_bin =8'd24   
)
(
    input                       clk,
    input                       rstn,
    input       [SIZE_bcd-1:0]  data_bcd,
    output  reg [SIZE_bin-1:0]  data_bin,
    output  reg                 valid 
);

reg [ 7:0] cnt;
reg [SIZE_bcd-1:0] data_bcd_temp;
reg [SIZE_bin-1:0] data_bin_temp;

localparam  CYCCLE = SIZE_bcd/4;    //十进制位数

always @(posedge clk ) begin
    if (!rstn) begin
        cnt <= 0;
    end
    else begin
        if(cnt > CYCCLE)
            cnt <= 0;
        else
            cnt <= cnt +1;
    end
end

always @(posedge clk ) begin 
    if(!rstn ) begin
        valid <= 1'd0;    
        data_bcd_temp <= 0;
        data_bin_temp <= 0;
    end 
    else begin
        if ( cnt == 0 ) begin
            valid     <= 1'd0;
            data_bcd_temp <= data_bcd;
            data_bin_temp <= 0;
        end
        else if( cnt <= CYCCLE ) begin
            data_bin_temp <=  MULTI10(data_bin_temp) + data_bcd_temp[(SIZE_bcd+3-cnt*4)-:4];     //注意位索引写法，表示8'd43-cnt*4开始低4位
        end
        else if ( cnt == CYCCLE +1 ) begin
            data_bin <= data_bin_temp;
            valid    <= 1'd1;
        end
    end
end
//加法和位拼接：乘10运算--*8+*2 
//注意：输出数据位数
function [SIZE_bin-1:0] MULTI10 (input [SIZE_bin-1:0] a);   
begin
    MULTI10 = {a[SIZE_bin-4 :0],3'b000 } + {a[SIZE_bin-2 :0],1'b0 };      
end
endfunction

endmodule
```

### 呼吸灯模块

#### 原理

呼吸灯为常见的数字IC设计案例，也比较简单，主要是关于呼吸灯的原理需要理解。常见的应用在手机的呼吸灯，这里我们采用硬件描述语言来实现LED呼吸灯的效果，即在1s内，LED灯由暗逐渐变亮，再1s内再由亮逐渐变暗。

呼吸灯设计原理归结为对于分频和占空比的应用，就是先分频，然后再设置占空比的设计。占空比也就是控制LED暗亮的时间达到具有呼吸灯的效果。

首先要引入 脉冲宽度调制（PWM） 的概念，LED的点亮和熄灭，是电平高低变换的结果，可以将一高一低看作一个周期，每个周期一亮一灭，会显示为LED的闪烁，当周期很短，也就是频率很高时，这种闪烁将不被肉眼识别，会让人产生LED连续发光的感觉。在一个周期内，高电平时长与一个周期时长的比叫做占空比，占空比越高，相当于通过LED的电流就越大，视觉上的感觉就越亮。说到这里，应该就有了做呼吸灯的思路，就是改变占空比！让占空比小幅度有级提升，就会有LED无级变亮的感觉。反之就会变暗。占空比越高，亮度越亮。

首先将1s 分为1000份（1ms），然后在1ms内在继续分为1000份（1us），每一个1ms内，依次增加亮灯时间

即:

第1个1ms内亮灯1us

第2个1ms内亮灯2us

第3个1ms内亮灯2us

… …

第1000个1ms内亮灯1000us

#### 程序展示

```verilog
module pwm(  //端口的定义，包括输入端口和输出端口
    input clk,
    input rst,
    input pwm_dip,
    output [14:0] led
    );

    reg [24:0] cnt_reg;     //计数寄存器
    reg [14:0] light;       //LED灯寄存器
    reg DIR=1'b1;           //判断标识符，决定灯光强度的下一步变化
    reg [24:0] value;       //用于占空比的设置
    reg [6:0] cs;           //占空比的变化趋势，1~100

    always @ (posedge clk)  //边缘敏感，时钟上升沿到来触发
    begin
    if(!rst || !pwm_dip)
    begin   //以下为变量的初始化
        cnt_reg <= 0;
        cs <= 7'd0;
        value <= 0;
    end
    else
        cnt_reg <= cnt_reg+1;                   //计数器加1
        if(cnt_reg == 500000)                   //经过一个单位时间
            begin           
            if(DIR) begin                       //DIR=1时灯光逐渐变亮
                value <= value + 19'd5000;      //占空比变大
                cnt_reg <= 20'd0;               //计数器归0
                cs <= cs + 1'b1;                //次数+1
            end
            else begin
                value <= value - 19'd5000;      //占空比变小
                cnt_reg <= 20'd0;               //计数器归0
                cs <= cs - 1'b1;                //次数-1
            end
            end
        end
    
    always@(cnt_reg) begin          //电平敏感，其中信号有变化即执行
    //占空比变化的实现
        if(cnt_reg < value) begin   //当前计数器的数小于valuie
            light <= 15'h7fff;      //全1，即亮
        end 
        else begin                  //当前计数器的数小于valuie
            light <= 15'h0000;      //全0，即暗
        end
    end
    
    always @ (value) begin
    if (cs == 100) begin            //当cs达到100后，即占空比达到了1，灯最亮
        DIR <= 1'b0; end            //DIR=0，意味着接下来要开始变暗了
    if (cs == 0) begin              //当cs达到.后，即占空比达到了0，灯最暗
        DIR <= 1'd1; end            //DIR=1，意味着接下来要开始变亮了
    end  
    assign  led = light;            //将寄存器中中保存的电平赋值给线路进行相应电平的输出    
endmodule
```

### AM调制模块

#### 原理

AM已调信号的时域表达式：
$$
\begin{aligned}
s_{\mathrm{AM}}(t) &=\left[A_{0}+m(t)\right] \cos \omega_{\mathrm{c}} t \\
&=A_{0} \cos \omega_{c} t+m(t) \cos \omega_{\mathrm{c}} t
\end{aligned}
$$
已调信号的频域表达式：
$$
S_{\mathrm{AM}}(\omega)&=\pi A_{0}\left[\delta\left(\omega+\omega_{\mathrm{c}}\right)+\delta\left(\omega-\omega_{\mathrm{c}}\right)\right]
\\
&+\frac{1}{2}\left[M\left(\omega+\omega_{\mathrm{c}}\right)+M\left(\omega-\omega_{\mathrm{c}}\right)\right]
$$
本质上AM调制就是频谱的搬移。

AM调制的过程就是将调制信号加上一个直流分量，保证信号的最小值大于零，然后再和载波相乘，得到已调信号。

我们将这个过程分为两部分来进行：

第一部分为调制信号和载波信号的生成。根据分辨率计算出位宽，调用两次DDS的IP核，分别产生调制信号和载波信号。

第二部分为调制部分：先乘以调制深度，再叠加直流分量，最后与载波相乘，这些都可以通过调用乘法器、加法器IP核实现。

设置DDS的输出位宽为8位，那么调制信号幅度大小-128到127（实际仿真为-126~126），需要叠加直流分量使调制信号幅度均为正值。

假设直流分量A为128，就可以得到标准式
$$
u(t)=127\left(1+m_{a} \frac{u_{\Omega}(t)}{128}\right) u_{c}(t)
$$
那么关于调制深度，由于不能直接显示小数，我们可以将ma*256取整，与调制信号相乘，再将结果右移8位即可。

#### 程序展示

```verilog
module AM_create(
	input		clk,
	input		rst_n,
	output	signed	[13:0]	AM_mod
);
wire    [15:0]AM_mod1;
wire 	[7:0]	cos_s;
wire	signed	[7:0]	cos_c;
assign AM_mod = AM_mod1[15:2];
//------------调用出波模块------------//
cos_make		cos_make_inst0(
	.clk			(clk),
	.rst_n		(rst_n),
	.cos_s		(cos_s),
	.cos_c		(cos_c)
);
//------------调用乘法器--------------//
MULT		MULT_inst1(		
  .CLK	(clk),
  .A		(cos_s),
  .B		(cos_c),
  .P		(AM_mod1)
);
endmodule
```

## 调试与结果

### 学号显示

#### testbench

```verilog
//seg_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module seg_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
initial begin
     clk = 0;
     rst_n = 0; #(`Clock*20+1);
     rst_n = 1;
     forever
         #(`Clock/2) clk = ~clk;
end
seg_display seg_left(
    .clk   ( clk   ),
    .rst_n ( rst_n ),
    .hex0  ( 4'h2 ),
    .hex1  ( 4'h0  ),
    .hex2  ( 4'h2  ),
    .hex3  ( 4'h2  ),
    .dp_in ( 4'b1000 ),
    .an    ( an1    ),
    .sseg  ({dp1,sseg1} )
);
seg_display seg_right(
    .clk   ( clk   ),
    .rst_n ( rst_n ),
    .hex0  ( 4'h0 ),
    .hex1  ( 4'h1  ),
    .hex2  ( 4'h1  ),
    .hex3  ( 4'h8  ),
    .dp_in ( 4'b0000 ),
    .an    ( an2    ),
    .sseg  ({dp2,sseg2} )
);
endmodule
```

#### 仿真结果

<img src="https://s1.ax1x.com/2022/11/05/xODXIU.png" alt="image-20221102210013403"  />

### 开关输入频率控制字的DDS

#### testbench

```verilog
//swDDS_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module swDDS_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
    wire [13:0] o_wave;
    reg [7:0] sw;
    wire [3:0] ones,tens,huns,thous,tenk,hunk,onem;
    wire clk_div10,clk_div104,clk_div106;

    initial begin
        clk = 0;
        sw = 8'b0000_0000;
        rst_n = 0; #(`Clock*20+1);
        rst_n = 1;
     forever
         #(`Clock/2) clk = ~clk;
    end
    always@(posedge clk_div106)begin
        sw <= sw+1;
    end
    freq_div10#(
        .DIV_0CLK ( 10000 )
    )freq_div104(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div104 )
    );
    freq_div10#(
        .DIV_0CLK ( 100 )
    )freq_div106(
        .clk   ( clk_div104   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div106 )
    );
    freq_div10#(
        .DIV_0CLK ( 10 )
    )freq_div10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10 )
    );

    DDS8 u_DDS8(
        .clk   (clk_div10),
        .rst_n (  rst_n ),
        .FRQ_W ( sw[5:0]),
        .o_wave( o_wave )
    );
//由于篇幅有限，此处省略转BCD模块和数码管模块的例化
endmodule
```

#### 仿真结果

##### 整体仿真

![image-20221102222613236](https://s1.ax1x.com/2022/11/05/xODOaT.png)

##### 频率控制字为1时的波形

仿真波形图测得产生的正弦波频率为40KHZ，理论上当频率控制字为1时产生的频率应为39.062KHZ，相差约1KHZ。

![image-20221102223401397](https://s1.ax1x.com/2022/11/05/xODLZV.png)

##### 频率控制字为12时的波形

仿真波形图测得频率为468384HZ，理论频率为468750HZ，误差为366HZ。

![image-20221102224204992](https://s1.ax1x.com/2022/11/05/xODHrq.png)

### 测频

#### testbench

```verilog
//fre_tb.v
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期

module fre_tb();
    reg clk;
    reg rst_n;
    wire [3:0] an1,an2;
    wire [6:0] sseg1,sseg2;
    wire dp1,dp2;
    wire [13:0] o_wave;
    wire [3:0] AD0,AD1,AD2,AD3,AD4,AD5,AD6;
    wire clk_div10;
    initial begin
        clk = 0;
        forever
            #(`Clock/2) clk = ~clk;
    end
    initial begin
        rst_n = 0; #(`Clock*200+1);
        rst_n = 1;
    end
    freq_div10#(
        .DIV_0CLK ( 10 )
    )freq_div10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10 )
    );
    DDS8 u_DDS8(
        .clk   (clk_div10),
        .rst_n (  rst_n ),
        .FRQ_W (   1   ),
        .o_wave( o_wave )
    );
    AD_fre u_AD_fre(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AD_in ( o_wave[13:4] ),
        .AD0   ( AD0   ),
        .AD1   ( AD1   ),
        .AD2   ( AD2   ),
        .AD3   ( AD3   ),
        .AD4   ( AD4   ),
        .AD5   ( AD5   ),
        .AD6   ( AD6   )
    );
    seg_display seg_left(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( 4'h0 ),
        .hex1  ( AD6  ),
        .hex2  ( AD5  ),
        .hex3  ( AD4  ),
        .dp_in ( 4'b0000 ),
        .an    ( an1    ),
        .sseg  ( {dp1,sseg1} )
    );
    seg_display seg_right(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( AD3 ),
        .hex1  ( AD2  ),
        .hex2  ( AD1  ),
        .hex3  ( AD0  ),
        .dp_in ( 4'b0001 ),
        .an    ( an2    ),
        .sseg  ( {dp2,sseg2} )
    );
endmodule
```

#### 仿真结果

##### 频率控制字为1时

![image-20221103005543711](https://s1.ax1x.com/2022/11/05/xODbq0.png)

理论频率值为$\frac{1\times10M}{2^8}=39062HZ$，仿真测得频率为$39062HZ$，完全一致。

##### 频率控制字为46时

![image-20221103200031708](https://s1.ax1x.com/2022/11/05/xODviF.png)

理论频率值为$\frac{46\times10M}{2^8}=1796875HZ$，仿真测得频率为$1796860HZ$，相对误差为$-0.00083\%$。

### 蓝牙输入频率控制字的DDS

#### testbench

由于模拟串口数据发送端较为困难，在此略过串口部分，仅仅将命令解析后的数据送入其他模块仿真，观察dds产生的波形频率误差。

```verilog
`timescale 1ns / 1ps
`define    Clock 10 //时钟周期
module bluebooth_tb();
    reg clk;
    reg rst_n1,rst_n0;
    wire    clk_div10;
    reg    [31:0]  bt_data32;
    wire    [23:0]  bt_bin;             //转换为二进制之后的串口数据
    wire            bt_valid;           //转换可用标志
    reg     [20:0]  btbin_fil;          //经过溢出检查之后的串口数据
    wire    [11:0]  bt_fil;             //串口数据转化成的频率控制字
    wire    [35:0]  mid_var;            //计算中间变量
    wire    [13:0]  bt_wave;
    initial begin
        clk = 0;
        bt_data32={4'h0,4'h0,4'h7,4'h8,4'h0,4'h0,4'h0,4'h0};
        forever
            #(`Clock/2) clk = ~clk;
    end
    initial begin
        rst_n1 = 0;
        rst_n0 = 0;
        #(`Clock*20+1);
        rst_n0 = 1;//快复位
        #(`Clock*20+1);
        rst_n1 = 1;//慢复位
    end
    always @(*) begin               //蓝牙输入的溢出判断
        if(bt_valid)begin
            if(bt_bin>24'd2000000)begin
                btbin_fil<=24'd2000000;
            end
            else begin
                btbin_fil<=bt_bin;
            end
        end
    end
    assign mid_var = (btbin_fil<<14);
    assign bt_fil = mid_var/10000000;
        freq_div10#(
        .DIV_0CLK ( 10 )
        )clkdiv10(
        .clk   ( clk   ),
        .rst_n ( rst_n1 ),
        .clk_div10  ( clk_div10  )
        );
    bcd_bin#(
        .SIZE_bcd ( 28 ),
        .SIZE_bin ( 24 )
    )u_bcd_bin(
        .clk      ( clk              ),
        .rstn     ( rst_n0            ),
        .data_bcd ( bt_data32[27:0]  ),
        .data_bin ( bt_bin           ),
        .valid    ( bt_valid         )
    );
    DDS14 btdds(            //14*2^14 DDS
        .clk   ( clk_div10 ),
        .rst_n ( rst_n0     ),
        .FRQ_W ( bt_fil    ),
        .o_wave( bt_wave   )
    );
endmodule
```



#### 仿真结果

![蓝牙dds](https://s1.ax1x.com/2022/11/05/xXibX8.png)

可以看出，理论频率为780000HZ，实际仿真波形频率为781250HZ，误差为1250HZ，在要求的2KHZ以内。

### 呼吸灯

#### testbench

```verilog
`timescale 1ns / 1ps
module PWM_tb();
reg 	clk;
reg		rst_n;
reg     pwm_dip;
wire 	[14:0]	led;
initial		clk = 1;
always	#5	clk = ~clk;		//100M时钟
initial	begin
    pwm_dip=1;
	rst_n = 0;
	#500
	rst_n = 1;
end
pwm u_pwm(
    .clk     ( clk     ),
    .rst     ( rst_n   ),
    .pwm_dip ( pwm_dip ),
    .led     ( led     )
);
endmodule
```

#### 仿真结果

![呼吸灯仿真](https://s1.ax1x.com/2022/11/05/xXSbCV.png)

### AM调制

#### testbench

```verilog
`timescale 1ns / 1ps
module tb_AM();
//---------接口设置----------//
reg 	sclk;
reg		rst_n;
wire 	signed	[13:0]	AM_mod;
//--------------------------//
initial		sclk = 1;
always	#5	sclk = ~sclk;		//100M时钟
initial	begin
	rst_n = 0;
	#500
	rst_n = 1;
end
//--------------------------//
AM_create		modulate_inst0(
	.clk		(sclk),
	.rst_n		(rst_n),
	.AM_mod		(AM_mod)
);
endmodule
```

#### 仿真结果

![AM仿真](https://s1.ax1x.com/2022/11/05/xXSlnJ.png)



## 收获与体验

1. Verilog程序需要用并发的思维去编写。

   软件代码的执行是一个顺序的过程，编绎以后的机器码放在存储器里，等着CPU一条一条的取指并执行；因此软件设计中经常会带有顺序处理的思维。而逻辑设计则不同，我们设计的是数字电路，它是由很多很多的与非门及D触发器构成的，上电之后所有与非门和D触发器都同时工作，不会因为A触发器的代码描述在B触发器之前A触发器就是先工作，事实上，RTL级代码的代码先后顺序在综合成网表文件后这种顺序就消失了，取代的是基本逻辑电路之间的互联关系描述；因此逻辑设计需要的是一种并发的思维，我们也需要用并发的思维去考虑电路的设计。

2. 时序是很重要的问题。不是说上板子结果没问题就大功告成，仿真这一步就是去检查时序设计是否符合逻辑的。当仿真出现不定态或者高阻态时，一定要注意检查时序问题。

3. 通过这次实验，我对verilog语言的语法和程序结构有了新的认识，并基本熟练使⽤VIVADO平台对FPGA进行开发。



# 参考文献

- [verilog 分频器设计(奇偶分频、半整数分频、任意分频、任意占空比)](https://zhuanlan.zhihu.com/p/450117801?utm_id=0)

- [二进制转换成BCD的原理与verilog实现 --加3左移](https://blog.csdn.net/qq_40011737/article/details/121127850)

- [DDS发生器的verilog实现（三）](https://blog.csdn.net/qq_34769608/article/details/110058982)

- [用verilog模拟DDS产生正弦波信号](https://www.cnblogs.com/christsong/p/5536995.html)

- [verilog实现DDS](https://www.cnblogs.com/yskn/p/9321697.html)

- [使用matlab生成正弦波、三角波、方波的COE文件](https://blog.csdn.net/yindq1220/article/details/125173035)

- [FPGA频率测量的三种方法（直接测量法，间接测量法，等精度测量法）](https://blog.csdn.net/wuzhikaidetb/article/details/112326945)

- [verilog:一种可选位宽的BCD到二进制和二进制到BCD串行转换实现](https://blog.csdn.net/qq_40011737/article/details/121375603?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121375603-blog-121195609.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121375603-blog-121195609.pc_relevant_recovery_v2&utm_relevant_index=9)

- [verilog:一种资源节约型的BCD码转二进制码模块](https://blog.csdn.net/qq_40011737/article/details/121195609)

- [AM调制的FPGA实现](https://blog.csdn.net/HOOKNET/article/details/79129451)

- [【FPGA】基于vivado的AM调制与解调（verilog）（一、理论知识篇）](https://blog.csdn.net/dovings/article/details/106888876?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-106888876-blog-79129451.pc_relevant_layerdownloadsortv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-106888876-blog-79129451.pc_relevant_layerdownloadsortv1&utm_relevant_index=7)

- [FPGA基础入门篇（九）使用 Verilog 实现 LED 呼吸灯效果](https://weivid.blog.csdn.net/article/details/99689858?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-99689858-blog-52691431.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-99689858-blog-52691431.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2)

# Verilog HDL程序

此处只放出顶层模块代码，其余代码在[我的GitHub仓库](https://github.com/starbovo/Digital-System-Design2022)里面，欢迎老师和各位同学参考。

```verilog
`timescale 1ns / 1ps
/*
please use GB2312 to open this file
designed by ZhaoJingxuan
final version in 2022/10/27
*/
module top_module(
    //100M时钟和复位信号
    input clk,
    input rst_n,
    //两个拨码开关和八个普通开关
    input   [1:0]   sw_mode,
    input   [7:0]   sw,
    //一个开关控制DDS频率控制字来源
    input dds_dip,
    input AM_dip,
    output dds_led,
    //呼吸灯15位输出，一个开关控制
    input pwm_dip,
    output [14:0] led,
    //串口引脚RX、TX
    input           rxd_pin,
    output          txd_pin,
    //蓝牙控制
    output bt_pw_on,
    output bt_master_slave,
    output bt_sw_hw,
    output bt_rst_n,
    output bt_sw,
    //AD和DA时钟
    output reg AD_clk,
    output reg DA_clk,
    //10位AD输入
    input   [9:0]   AD_in,
    //DA输出
    output [13:0] DA_out,//提供给DA转换器的信号
    //数码管引脚
    output [3:0] an1,   //片选
    output [7:0] sseg1,  //段选
    output [3:0] an2,   //片选
    output [7:0] sseg2  //段选
    );
    //十分频出来的10M时钟
    wire clk_div10;
    //DDS相关信号
    reg     [13:0]  o_wave;
    wire    [13:0]  sw_wave,bt_wave;
    reg             dds_state = 1'b0;    //DDS输出模式标志（sw or bt）
    wire signed	[13:0]	AM_mod;
    //下面是一堆数码管中间信号
    wire    [3:0]   DA0,DA1,DA2,DA3,DA4,DA5,DA6;
    wire    [3:0]   AD0,AD1,AD2,AD3,AD4,AD5,AD6;
    reg     [3:0]   num0,num1,num2,num3,num4,num5,num6,num7,dp0,dp1;
    //蓝牙接收到的数据的BCD信号（8位数字）
    wire    [31:0]  bt_data32;
    //经过溢出检查（计算后不超过2M）后的开关信号
    reg     [7:0]   sw_fil;
    //串口数据转二进制
    wire    [23:0]  bt_bin;             //转换为二进制之后的串口数据
    wire            bt_valid;           //转换可用标志
    //串口数据溢出检查
    reg     [20:0]  btbin_fil;          //经过溢出检查之后的串口数据
    wire    [11:0]  bt_fil;             //串口数据转化成的频率控制字
    wire    [35:0]  mid_var;            //计算中间变量，因为verilog隐藏线型最大32位不够
    //十分频时钟
        freq_div10#(
        .DIV_0CLK ( 10 )
        )clkdiv10(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .clk_div10  ( clk_div10  )
        );
    //将10M时钟给AD和DA模块的时钟
    always@(*)begin
        AD_clk<=clk_div10;
        DA_clk<=clk_div10;
    end
    //通过两位拨码开关选择模式
    always @(*)         
        begin
            case(sw_mode)
                2'b00:begin    //00显示2022+学号后四位（0118）
                    num7=4'h2;
                    num6=4'h0;
                    num5=4'h2;
                    num4=4'h2;
                    num3=4'h0;
                    num2=4'h1;
                    num1=4'h1;
                    num0=4'h8;
                    dp0=4'b1000;
                    dp1=4'b0000;
                  end    
                2'b01: begin    //01显示开关控制下的输出频率
                    num7=4'h0;
                    num6=DA6;
                    num5=DA5;
                    num4=DA4;
                    num3=DA3;
                    num2=DA2;
                    num1=DA1;
                    num0=DA0;
                    dp0=4'b0000;
                    dp1=4'b0001;
                    end
                2'b10: begin    //10显示AD测量频率结果
                    num7=4'h0;
                    num6=AD6;
                    num5=AD5;
                    num4=AD4;
                    num3=AD3;
                    num2=AD2;
                    num1=AD1;
                    num0=AD0;
                    dp0=4'b0000;
                    dp1=4'b0001;
                    end
                2'b11: begin    //11显示蓝牙控制下的输出频率
                    num7=bt_data32[31:28];
                    num6=bt_data32[27:24];
                    num5=bt_data32[23:20];
                    num4=bt_data32[19:16];
                    num3=bt_data32[15:12];
                    num2=bt_data32[11:8];
                    num1=bt_data32[7:4];
                    num0=bt_data32[3:0];
                    dp0=4'b0000;
                    dp1=4'b0001;
                end
            endcase
        end
    //溢出判断
    always @(*) begin               //开关输入的溢出判断
    //fout为2M时，频率控制字为2M*(2^8)/10M=8'd51=8'b00110011
        if(sw>8'b00110011)begin     //超出110011则赋为它
            sw_fil <= 8'b00110011;
        end
        else begin                  //未超出则保持原值
            sw_fil <= sw;
        end
    end
    always @(*) begin               //蓝牙输入的溢出判断
        if(bt_valid)begin
            if(bt_bin>24'd2000000)begin
                btbin_fil<=24'd2000000;
            end
            else begin
                btbin_fil<=bt_bin;
            end
        end
    end
    //频率控制字为fout*10M/2^14
    //因为要求误差小于2KHZ，意味着频率步进缩小到4KHZ
    //此时最小深度为4KHZ/(1*10MHZ)=2^14
    //所以蓝牙DDS输出时要采用不同的coe文件
    assign mid_var = (btbin_fil<<14);
    assign bt_fil = mid_var/10000000;
    //开关切换频率控制字来源，如果是蓝牙模式灯亮
    always@(*) begin
        if(AM_dip)
            o_wave<=AM_mod;
        else begin
            if(dds_dip)begin
                dds_state <= 1;
                o_wave<=bt_wave;
            end
            else begin
                dds_state <= 0;
                o_wave<=sw_wave;
            end
        end
    end
    assign dds_led = dds_state;
    assign DA_out = o_wave;
    //例化两个DDS
    DDS8 swdds(             //8*2^8 DDS
        .clk   ( clk_div10  ),
        .rst_n ( rst_n      ),
        .FRQ_W ( sw_fil[5:0]),
        .o_wave( sw_wave    )
    );
    DDS14 btdds(            //14*2^14 DDS
        .clk   ( clk_div10 ),
        .rst_n ( rst_n     ),
        .FRQ_W ( bt_fil    ),
        .o_wave( bt_wave   )
    );
    //例化AD测频模块
    AD_fre u_AD_fre(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AD_in ( AD_in ),
        .AD0   ( AD0   ),
        .AD1   ( AD1   ),
        .AD2   ( AD2   ),
        .AD3   ( AD3   ),
        .AD4   ( AD4   ),
        .AD5   ( AD5   ),
        .AD6   ( AD6   )
    );
    //例化蓝牙接收模块
    bt_uart u_bt_uart(
        .clk_pin         ( clk             ),
        .rst_pin         ( rst_n           ),
        .rxd_pin         ( rxd_pin         ),
        .txd_pin         ( txd_pin         ),
        .bt_pw_on        ( bt_pw_on        ),
        .bt_master_slave ( bt_master_slave ),
        .bt_sw_hw        ( bt_sw_hw        ),
        .bt_rst_n        ( bt_rst_n        ),
        .bt_sw           ( bt_sw           ),
        .bt_data32       ( bt_data32       )
    );
    //例化28bitsBCD码转24bits二进制模块
    bcd_bin#(
        .SIZE_bcd ( 28 ),
        .SIZE_bin ( 24 )
    )u_bcd_bin(
        .clk      ( clk              ),
        .rstn     ( rst_n            ),
        .data_bcd ( bt_data32[27:0]  ),
        .data_bin ( bt_bin           ),
        .valid    ( bt_valid         )
    );
    //例化24bits二进制转28bitsBCD码模块
    sw_BCD swin(        //开关输入的信号转BCD码
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .sw    ( sw_fil),
        .ones  ( DA0  ),
        .tens  ( DA1  ),
        .huns  ( DA2  ),
        .thous ( DA3  ),
        .tenk  ( DA4  ),
        .hunk  ( DA5  ),
        .onem  ( DA6  )
    );
    //八个数码管例化
    seg_display seg_left(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( num7  ),
        .hex1  ( num6  ),
        .hex2  ( num5  ),
        .hex3  ( num4  ),
        .dp_in ( dp0   ),
        .an    ( an1   ),
        .sseg  ( sseg1 )
    );
    seg_display seg_right(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .hex0  ( num3  ),
        .hex1  ( num2  ),
        .hex2  ( num1  ),
        .hex3  ( num0  ),
        .dp_in ( dp1   ),
        .an    ( an2   ),
        .sseg  ( sseg2 )
    );
    //呼吸灯模块例化
    pwm u_pwm(
        .clk     ( clk     ),
        .rst     ( rst_n   ),
        .pwm_dip ( pwm_dip ),
        .led     ( led     )
    );
    AM_create u_AM_create(
        .clk   ( clk   ),
        .rst_n ( rst_n ),
        .AM_mod  ( AM_mod  )
    );
endmodule
```

